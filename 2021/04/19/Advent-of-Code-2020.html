<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Advent of Code 2020" />
<meta name="author" content="Hannah Lenk" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="My most valued readers! So glad you could drop by again! You are just in time to catch me singing the praises - almost as belated as they are deserved - for an annual coding competition that can be classified as the highlight of many a programmer each year. In addition, I also show and explain all my solutions for it." />
<meta property="og:description" content="My most valued readers! So glad you could drop by again! You are just in time to catch me singing the praises - almost as belated as they are deserved - for an annual coding competition that can be classified as the highlight of many a programmer each year. In addition, I also show and explain all my solutions for it." />
<link rel="canonical" href="http://localhost:4000/2021/04/19/Advent-of-Code-2020.html" />
<meta property="og:url" content="http://localhost:4000/2021/04/19/Advent-of-Code-2020.html" />
<meta property="og:site_name" content="code" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-04-19T02:59:26+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Advent of Code 2020" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Hannah Lenk"},"dateModified":"2021-04-19T02:59:26+02:00","datePublished":"2021-04-19T02:59:26+02:00","description":"My most valued readers! So glad you could drop by again! You are just in time to catch me singing the praises - almost as belated as they are deserved - for an annual coding competition that can be classified as the highlight of many a programmer each year. In addition, I also show and explain all my solutions for it.","headline":"Advent of Code 2020","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2021/04/19/Advent-of-Code-2020.html"},"url":"http://localhost:4000/2021/04/19/Advent-of-Code-2020.html"}</script>
<!-- End Jekyll SEO tag -->
<title>code&lt;metas&gt; | Advent of Code 2020</title>
	<link rel="stylesheet" href="/assets/main.css">
	<link rel="icon" type="image/svg+xml" href="/assets/logo.svg"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="code&lt;metas&gt;" /></head>
<body><header class="site-header" role="banner">

	<div class="wrapper"><a class="site-title" rel="author" href="/"><span style="color:black"><img src=/assets/logo.svg>code</span><span style="color:white;">&ltmetas&gt</span></a><nav class="site-nav">
				<input type="checkbox" id="nav-trigger" class="nav-trigger" />
				<label for="nav-trigger">
					<span class="menu-icon">
						<svg viewBox="0 0 18 15" width="18px" height="15px">
							<path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
						</svg>
					</span>
				</label>

				<div class="trigger"><a class="page-link" href="/about.html">About</a><a class="page-link" href="/tag_directory.html">Tags</a><a target="_blank" class="page-link" href="https://courses.codemetas.de/course_info">Courses</a>
				</div>
			</nav></div>
</header>
<main class="page-content" aria-label="Content">
			<div class="left-side-decoration">
				<img  src=/assets/logo.svg>
			</div>
			<div class="wrapper">
				<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

	<header class="post-header">
		<h1 class="post-title p-name" itemprop="name headline">Advent of Code 2020</h1>
		<p class="post-meta">

			<time class="dt-published" datetime="2021-04-19T02:59:26+02:00" itemprop="datePublished">Apr 19, 2021
			</time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person">
					<span class="p-author h-card" itemprop="name">
						Hannah Lenk
					</span>
				</span>• <span>
					[
						<a href="/tag_directory.html#adventofcode">adventofcode</a>
						<a href="/tag_directory.html#2020">2020</a>
						<a href="/tag_directory.html#c++">c++</a>
					]
				</span></p>
	</header>

	<div class="post-content e-content" itemprop="articleBody">
		<p><em>My most valued readers! So glad you could drop by again! You are just in time to catch me singing the praises - almost as belated as they are deserved - for an annual coding competition that can be classified as the highlight of many a programmer each year. In addition, I also show and explain all my solutions for it.</em></p>

<p>In recent years, I have found myself increasingly looking forward to December. Not because of Christmas, not because of my birthday<sup id="fnref:celebrate" role="doc-noteref"><a href="#fn:celebrate" class="footnote" rel="footnote">1</a></sup>, not even because the best thing in each successive one seems to be it finally coming to a close - but because of <a href="https://adventofcode.com/">Advent of Code</a>.</p>

<p>In line with my more general resolution of being more open and public about everything I do<sup id="fnref:why" role="doc-noteref"><a href="#fn:why" class="footnote" rel="footnote">2</a></sup>, I decided I should note down my thoughts, document my experiences and publish my solutions this time around.</p>

<p>Keeping in line with my general tendencies, however, I am - of course - incredibly late to the party.<sup id="fnref:party" role="doc-noteref"><a href="#fn:party" class="footnote" rel="footnote">3</a></sup> Advent ended far more than 4 month ago and I only managed to complete this writeup now, not even in time to ruin the easter bunnys day<sup id="fnref:easter" role="doc-noteref"><a href="#fn:easter" class="footnote" rel="footnote">4</a></sup>.</p>

<p>Nonetheless, despite their seasonal framing, the problems posed are timeless, highly educational and results can be submitted even years after the original “end”. As such, I am hopeful my musings on this particular incarnation - though late - might still prove helpful, interesting and enjoyable to some of my dear readers.</p>

<p>One last word of warning before we get to it:<br />
I am aware, I do tend to say that <a href="/2020/06/22/klobigb_overview.html">Every.</a> <a href="/2020/07/15/A-plea-for-order.html">Single.</a> <a href="/2020/11/22/The-Royal-Game.html">Time.</a>, but this article really is structurally very different from all that came before it. Even if you enjoyed those, it might not come as a surprise if you don’t enjoy this one<sup id="fnref:excuse" role="doc-noteref"><a href="#fn:excuse" class="footnote" rel="footnote">5</a></sup>. 
I wrote a small introduction and a tiny conclusion tying it all together, but really, everything else was written rather independently. Therefore, this should maybe be viewed more like a collection of very small articles or commentaries - one for each day - instead of one grand, cohesive whole. You can freely jump around, look at only the explanations for a single day or even skip all code completely and just peruse my thoughts and opinions at the beginning and end.</p>

<div class="post_toc">
  <h4>Contents</h4>
  <blockquote>
<ul id="markdown-toc">
  <li><a href="#what-is-this-and-why-should-i-care" id="markdown-toc-what-is-this-and-why-should-i-care">What is this and why should I care?</a>    <ul>
      <li><a href="#community" id="markdown-toc-community">Community</a></li>
    </ul>
  </li>
  <li><a href="#solutions" id="markdown-toc-solutions">Solutions</a>    <ul>
      <li><a href="#setup-and-tooling" id="markdown-toc-setup-and-tooling">Setup and tooling</a></li>
      <li><a href="#disclaimer" id="markdown-toc-disclaimer">Disclaimer</a></li>
      <li><a href="#day-1" id="markdown-toc-day-1">Day 1</a></li>
      <li><a href="#day-2" id="markdown-toc-day-2">Day 2</a></li>
      <li><a href="#day-3" id="markdown-toc-day-3">Day 3</a></li>
      <li><a href="#day-4" id="markdown-toc-day-4">Day 4</a></li>
      <li><a href="#day-5" id="markdown-toc-day-5">Day 5</a></li>
      <li><a href="#day-6" id="markdown-toc-day-6">Day 6</a></li>
      <li><a href="#day-7" id="markdown-toc-day-7">Day 7</a></li>
      <li><a href="#day-8" id="markdown-toc-day-8">Day 8</a></li>
      <li><a href="#day-9" id="markdown-toc-day-9">Day 9</a></li>
      <li><a href="#day-10" id="markdown-toc-day-10">Day 10</a></li>
      <li><a href="#day-11" id="markdown-toc-day-11">Day 11</a></li>
      <li><a href="#day-12" id="markdown-toc-day-12">Day 12</a></li>
      <li><a href="#day-13" id="markdown-toc-day-13">Day 13</a></li>
      <li><a href="#day-14" id="markdown-toc-day-14">Day 14</a></li>
      <li><a href="#day-15" id="markdown-toc-day-15">Day 15</a></li>
      <li><a href="#day-16" id="markdown-toc-day-16">Day 16</a></li>
      <li><a href="#day-17" id="markdown-toc-day-17">Day 17</a></li>
      <li><a href="#day-18" id="markdown-toc-day-18">Day 18</a></li>
      <li><a href="#day-19" id="markdown-toc-day-19">Day 19</a></li>
      <li><a href="#day-20" id="markdown-toc-day-20">Day 20</a></li>
      <li><a href="#day-21" id="markdown-toc-day-21">Day 21</a></li>
      <li><a href="#day-22" id="markdown-toc-day-22">Day 22</a></li>
      <li><a href="#day-23" id="markdown-toc-day-23">Day 23</a></li>
      <li><a href="#day-24" id="markdown-toc-day-24">Day 24</a></li>
      <li><a href="#day-25" id="markdown-toc-day-25">Day 25</a></li>
    </ul>
  </li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a>    <ul>
      <li><a href="#closing-thoughts-on-this-edition" id="markdown-toc-closing-thoughts-on-this-edition">Closing thoughts on this edition</a></li>
      <li><a href="#what-now" id="markdown-toc-what-now">What now?</a></li>
    </ul>
  </li>
</ul>

  </blockquote>
</div>

<h1 id="what-is-this-and-why-should-i-care">What is this and why should I care?</h1>

<p>I really don’t think I can put it better than the creator himself, so allow me to first point out that Eric Wastl has presented many times on the topic and watching at least <a href="https://youtu.be/CFWuwNDOnIo">one of those presentations</a> is probably a more valuable investment of your time and attention.</p>

<p>If, however, you intend to stay with me for now and want the shortened, succinct version - also ripped directly from his talks - Advent of Code is what you get if you combine this<sup id="fnref:advent_credit" role="doc-noteref"><a href="#fn:advent_credit" class="footnote" rel="footnote">6</a></sup>:</p>

<p><img src="/images/advent_calendar.jpg" alt="Advent Calendar" title="An Advent Calendar" class="centered-image" width="40%" /></p>

<p>with something like these:</p>

<p><img src="/images/competitive_prog_sites.png" alt="A number of competitive programming sites" title="Not an exhaustive list and not an endorsement of any one of those sites!" class="centered-image" width="60%" /></p>

<p>Beginning on the first of December, each day leading up to Christmas you get another door to open and peer behind. Instead of discovering a piece of chocolate - as is usual in more common variations of an <a href="https://en.wikipedia.org/wiki/Advent_calendar">advent calendar</a> - each door reveals a brand new programming puzzle to solve, all of them flimsily tied together with a whimsical and endearing cover story.</p>

<p>Whilst this description alone might, to the uninitiated, sound nice but not particularly exciting, it being the only thing during the last 5 to 10 years that managed to motivate me to consistently wake up and be available at a specific time of day - let alone really early - should tell you there is something very special about it.</p>

<p>And indeed, there is much that differentiates it from other events and makes participating in Advent of Code a rewarding and unique experience:</p>

<ul>
  <li>
    <p>It is not tied to any specific tool, language or environment. In fact, special care is taken to keep the problems language agnostic and not give any one - compiled or otherwise - a significant edge over others<sup id="fnref:speed" role="doc-noteref"><a href="#fn:speed" class="footnote" rel="footnote">7</a></sup>. As you have to submit a solution, not the code which computes it, anything goes and you are free to chose whichever path you fancy. You can preprocess input, combine multiple tools, solve some puzzles with pen and paper, <a href="https://www.reddit.com/r/adventofcode/comments/kfnt2s/2020_day_18_part_1_outsourcing_the_solution_they/">crowdsource</a> or use whatever other crazy ideas you might come up with. Anything short of hacking the site is welcome and kind of the point. It really teaches you to solve the specific problem in front of you, just as you should do in this strange “real world” I have been hearing so much of.</p>
  </li>
  <li>
    <p>Its one of a kind two part structure not only increases accessibility but lends itself particularly well as a teaching tool. You see, you do not really get one puzzle each day, you get two, the second of which is unlocked after you successfully solved the first one! Most of the time it is a more complicated variation or an extension of the first part. The effect of this structure, as I see it, is twofold: On the one hand, even complete beginners do get at least one task each day they can realistically hope to solve. 
On the other hand, what you have learned in part 1 can and must immediately be applied in part 2, consolidating new knowledge and fostering true understanding. You have to rethink and optimize your approach, consider asymptotic complexity and benefit from keeping your code clean and extensible.</p>
  </li>
  <li>
    <p>The occasional interdependence of many tasks, as seen with the <a href="https://adventofcode.com/2019/day/2">notorious intcode problems</a> in 2019, serves as a wonderful incentive to not only keep code extensible from the start, but even regularly go back to maintain and clean it up. You never quite know if and when you might have to build on something written on a previous day and not considering that might come back to bite you. Again, reminiscent of and not entirely unlike this “real world” thing.</p>
  </li>
</ul>

<p>That list is not exhaustive and deeply personal, which is why I will stop now. There is, however, one aspect so important to deserve its own section in this introduction: What really sets Advent of Code apart - more than anything - from all other coding competitions I know of, is its amazing community.</p>

<h2 id="community">Community</h2>

<p>With more than <a href="https://adventofcode.com/2020/stats">150000 participants</a> vying for one of the coveted spots on <a href="https://adventofcode.com/2020/leaderboard">a global leaderboard</a> consisting of a very meager 100 places, one could expect a certain degree of hostility.</p>

<p>What is actually happening is, however, the very opposite. Seldom have I witnessed such incredible supportiveness in so competitive an environment. Everyone helps and encourages everyone else, providing tips and assistance when needed, comparing solutions, sharing thoughts and ideas and just in general being awesome to each other.</p>

<p>To name just one example, I invite you to scroll through this <a href="https://www.reddit.com/r/adventofcode/comments/k4ejjz/2020_day_1_unlock_crash_postmortem/">lovely reddit thread</a>, started by the creator himself after, on the very first day of this most recent edition, the servers collapsed under the unpredictably huge load on puzzle unlock. Who got onto the leaderboard on that day was more of a function of who got to the servers first upon their restart than who solved the problem most quickly. As such, no leaderboard points were given at all. Instead of disgruntled voices protesting the decision or complaints about the crash, you’ll find only words of encouragement and understanding.</p>

<p>That incident was not just a fluke either. Solving the puzzles simultaneously with thousands of others around the world, all with different backgrounds, preferences and varying levels of experience and skill provides ample opportunity to learn from and inspire each other. There are even <a href="https://www.reddit.com/r/adventofcode/comments/kjtmw0/introducing_your_aoc_2020_gettin_crafty_with_it/">special rewards for exceptionally creative solutions, visualizations and other ideas</a>. And memes. A lot of memes.</p>

<p>The community is, of course, not restricted to reddit exclusively. Many participants - all across the leaderboard - stream their solving live on platforms like twitch and youtube, searching github for “adventofcode” reveals more than 30000 repositories and various sub-communities maintain their own leaderboards.</p>

<p>Related blog posts also exist in abundance. Even if I most definitely won the race for most delayed wrap-up post, it is by far less of an excessive margin <a href="https://www.reddit.com/r/adventofcode/comments/mcgzox/2020_rust_is_it_too_late_for_advent_of_code/">than you might think</a>. In no particular order of timing and preference, as I love them all, here <a href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc">is</a> <a href="https://timvisee.com/blog/solving-aoc-2020-in-under-a-second/">a small</a> <a href="https://cestlaz.github.io/post/advent-2020-final-thoughts/">selection</a> <a href="https://explog.in/notes/aoc.html">of</a> <a href="https://dannyvankooten.com/solving-advent-of-code-2020-under-1-second/">wrap-up posts</a>. There are many more and I encourage you to search for them.</p>

<p>Regardless, I promised to keep this short. Enough preamble, let’s leave the gushing for another day and move on to finally discuss solutions.</p>

<h1 id="solutions">Solutions</h1>

<h2 id="setup-and-tooling"><a href="https://github.com/philipplenk/adventofcode20/tree/main/tools">Setup and tooling</a></h2>

<p>If you read my remarks above attentively, you will know that choosing which set of languages and tools to employ is a pivotal decision. Allow me to briefly explain my sophisticated thought process on that matter:</p>

<p><em>If all you have is a hammer, everything looks like a nail. If your favorite tool is a very efficient hammer, you can beat everything into submission until it wishes it were one.</em></p>

<p>Naturally, I exclusively used C++.</p>

<p>I am a lot of things, and one of them is ambitious in all the wrong ways. Last year, I made it onto the global leaderboard just once and I intended to improve on that.<sup id="fnref:failure" role="doc-noteref"><a href="#fn:failure" class="footnote" rel="footnote">8</a></sup> To improve my chances of doing so, I did the bare minimum of preparation and composed a few simple scripts automating repetitive, time consuming site interactions. Nothing fancy, just one <a href="https://github.com/philipplenk/adventofcode20/blob/main/tools/submit_result.sh">for submission</a>, one for <a href="https://github.com/philipplenk/adventofcode20/blob/main/tools/fetch_input.sh">fetching the input</a>, <a href="https://github.com/philipplenk/adventofcode20/blob/main/tools/init.sh">copying and opening a boilerplate ready base file</a> for each day and a very <a href="https://github.com/philipplenk/adventofcode20/blob/main/base/Makefile">simplistic Makefile</a> tying them together.</p>

<h2 id="disclaimer">Disclaimer</h2>

<p>All explanations that follow are also reproduced in a <a href="https://github.com/philipplenk/adventofcode20">github repository</a>, next to the code they pertain to. So if you are only interested in a solution for one specific day, it might be better to just head over there and browse to the corresponding folder.</p>

<p>They also - obviously - spoil the fun of solving the problems on your own. So, if you happen to know me personally and your name starts with H, J, K, M, R or S or if you simply wish to - as opposed to being forced to - do the puzzles on your own first, <a href="#conclusion">skip</a> what is written below and return to compare once you are ready ;-) You may consider me sorely disappointed if you look at the solutions before your own attempts.</p>

<p>WHAT FOLLOWS DOES CERTAINLY NOT CONTAIN THE BEST CODE I HAVE EVER WRITTEN. I solved all of them at the time they appeared, which was 6 am in the morning where I live, between 8 - 12 hours ahead of my normal waking time xD</p>

<h2 id="day-1"><a href="https://github.com/philipplenk/adventofcode20/tree/main/01">Day 1</a></h2>

<h3 id="part-1">Part 1</h3>

<p>The first puzzle was simply finding two elements in a list of numbers which sum to another number(in our case the then current year, 2020).</p>

<p>This can, of course, be solved trivially in quadratic time, as can be seen in <a href="https://github.com/philipplenk/adventofcode20/tree/main/01/01_nested_loop.cpp">01_nested_loop.cpp</a>:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">vals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="mi">2020</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">//found it!</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>If we want to <a href="https://github.com/philipplenk/adventofcode20/tree/main/01/01_binary_search.cpp">get fancy</a>, we can sort our input in O(n log n) time, iterate over it and find the potentially corresponding number in O(log n) time, yielding a total running time of O(n log n) again:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">vals</span><span class="p">));</span>
		
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">v</span><span class="o">:</span><span class="n">vals</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">binary_search</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span><span class="mi">2020</span><span class="o">-</span><span class="n">v</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="c1">//found it!</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>Yes, <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">binary_search in the standard library returns a boolean</a>. This is one of the rare occasions where that is actually exactly what we want. For all the others, there is <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">lower_bound</a> and <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">upper_bound</a>.</p>

<p>That is rather nice, but if we are willing to sacrifice just a tiny little bit of additional memory(O(m) with m being the searched for sum) and assume all numbers are non-negative we could <a href="https://github.com/philipplenk/adventofcode20/tree/main/01/01.cpp">even go linear</a>:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">2021</span><span class="o">&gt;</span> <span class="n">seen</span><span class="p">{};</span>
		
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">v</span><span class="o">:</span> <span class="n">vals</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="o">&gt;</span><span class="mi">2020</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
	
	<span class="n">seen</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">seen</span><span class="p">.</span><span class="n">test</span><span class="p">(</span><span class="mi">2020</span><span class="o">-</span><span class="n">v</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="c1">//found it!</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>Without the assumption of non-negativity - which held for my input, but might not for everyones -  we can still do a variation of this, but would have to use significantly more memory and/or rely on some sort of hashset.</p>

<h3 id="part-2">Part 2</h3>

<p>For a tiny bit more difficulty (and were the numbers bigger also a significant spike in runtime for the trivial solutions), the second part asks us to find three numbers that sum to 2020. Luckily for us, the list is reasonably short and even the <a href="https://github.com/philipplenk/adventofcode20/tree/main/01/02_nested_loop.cpp">now cubic nested for loops</a> produce the correct result in a very short time(a very small fraction of a second on even my old machine):</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">k</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">vals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">vals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="mi">2020</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="c1">//found it!</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>Both of our slightly more sophisticated methods for part 1 can relatively easily be adapted to this new constraint. For the one applying sorting, simply add yet another for loop, yielding a O(n^2 log(n)) runtime. <a href="https://github.com/philipplenk/adventofcode20/tree/main/01/02_binary_search.cpp">Nothing to write home about</a>, but a step up from cubic…</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">vals</span><span class="p">));</span>
	
<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">2020</span><span class="o">-</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">vals</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">binary_search</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span><span class="n">target</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="c1">//found it!</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>Again, we can get rid of that tiny annoying log(n) factor, given the same assumptions and using the same technique as above. Adding another for loop results in <a href="https://github.com/philipplenk/adventofcode20/tree/main/02/02.cpp">the following code</a>, for “only” quadratic time.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">2021</span><span class="o">&gt;</span> <span class="n">seen</span><span class="p">{};</span>
		
<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">2020</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
	<span class="n">seen</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">2020</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="n">seen</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
		
		<span class="k">const</span> <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">2020</span><span class="o">-</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">vals</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		
		<span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="o">&lt;</span><span class="mi">2021</span> <span class="o">&amp;&amp;</span> <span class="n">target</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">seen</span><span class="p">.</span><span class="n">test</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">vals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">target</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>More than sufficient for the small input set, yet I really did not like stopping here.</p>

<p>Whilst it remains an open research problem whether or not the general <a href="https://en.wikipedia.org/wiki/3SUM">3SUM problem</a> is solvable in subquadratic time, we do have some additional constraints. Our input consists of only non-negative integers smaller or equal to our target value. Wikipedia claims that for integers in range -n to n there exists a solution in O(n log n) utilizing a Fast Fourier Transform on the input set represented as a bit vector, but unfortunately I failed to understand how exactly such a solution could be constructed.</p>

<p>So I tried to find a different, better solution, gave it a tiny bit more thought and my contemplations yielded <a href="https://github.com/philipplenk/adventofcode20/tree/main/01/02_wrong.cpp">the following code</a>:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">vals</span><span class="p">));</span>	
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">lower</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">higher</span> <span class="o">=</span> <span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="n">lower</span><span class="o">&lt;</span><span class="n">higher</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">2020</span><span class="o">-</span><span class="n">vals</span><span class="p">[</span><span class="n">lower</span><span class="p">]</span><span class="o">-</span><span class="n">vals</span><span class="p">[</span><span class="n">higher</span><span class="p">];</span>
	<span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">binary_search</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span><span class="n">target</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="c1">//found it!</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">lower</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">vals</span><span class="p">[</span><span class="n">lower</span><span class="p">]</span><span class="o">&lt;</span><span class="n">vals</span><span class="p">[</span><span class="n">higher</span><span class="p">]</span><span class="o">-</span><span class="n">vals</span><span class="p">[</span><span class="n">higher</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
		<span class="o">++</span><span class="n">lower</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">--</span><span class="n">higher</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>The runtime is bounded fairly simple: lower and higher start n values apart from each other and in each iteration either one is moved towards the other or a solution is found. As such, the while loop runs at most n times. The most expensive operation within is the binary search, running in log n time. As such, the overall complexity is O(n<em>log(n)) (for sorting) + O(n</em>log(n)) (for the loop), yielding a glorious O(n*log(n)) in total!</p>

<p>That is all fine and dandy, it even worked for my input and the few others I could find and try it on at the time, but that alone is far from sufficient to prove it could work for any input. As such, I tried to sketch a proof and in so doing quickly had to come to a shattering realization: <strong>this is completely wrong and ridiculously stupid!</strong></p>

<p>For instance, it fails with the following simple input:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 9 1009 1010 2000
</code></pre></div></div>

<p>Nonetheless, I considered this failure educational and working out why it works for some inputs and how exactly it fails so spectacularly on many others can be quite instructive, which is why I still showcase it here.</p>

<h2 id="day-2"><a href="https://github.com/philipplenk/adventofcode20/tree/main/02">Day 2</a></h2>

<h3 id="part-1-1">Part 1</h3>

<p>The second day was algorithmically far easier(and imho less interesting) than the first one, as the only difficulty here was avoiding typos and parsing the input. You got a list of words and <em>policies</em>, which described how to determine if a given word was valid:</p>

<p>1-3 p: word</p>

<p>Count the occurrences of the given letter(p) in the given word(word) and check it is present between the lower(1) and higher(3) bound times. We then had to count the number of valid words, i.e. words that satisfied their own policy.</p>

<p>Really, this was mostly just a typing speed challenge, with standard algorithms doing the bulk of the work. I simply defined a struct describing one such rule/word pair:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">policy_word</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">letter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>Followed by overloading operator«(lazily, without any error handling), so I could extract properly typed input from stdin:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">policy_word</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">min</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">dummy</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">max</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">letter</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">dummy</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">p</span><span class="p">.</span><span class="n">str</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="n">in</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>That allowed me to conveniently combine istream_iterator and std::count_if to solve the actual problem:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">count_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">policy_word</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},{},[](</span><span class="k">auto</span> <span class="n">pw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">cnt</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">count</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">pw</span><span class="p">.</span><span class="n">str</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">pw</span><span class="p">.</span><span class="n">str</span><span class="p">),</span><span class="n">pw</span><span class="p">.</span><span class="n">letter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="o">&gt;=</span><span class="n">pw</span><span class="p">.</span><span class="n">min</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span><span class="o">&lt;=</span><span class="n">pw</span><span class="p">.</span><span class="n">max</span><span class="p">;</span>
<span class="p">})</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span></code></pre>
</figure>

<h3 id="part-2-1">Part 2</h3>

<p>Part 2 was even more trivial, as the interpretation of the policies was changed. Now a valid word has to have the given letter at exactly one of the given positions. Simply change the validity checking lambda and you get the following code:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">count_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">policy_word</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},{},[](</span><span class="k">auto</span> <span class="n">pw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pw</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="n">pw</span><span class="p">.</span><span class="n">min</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="n">pw</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="n">pw</span><span class="p">.</span><span class="n">max</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pw</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="n">pw</span><span class="p">.</span><span class="n">min</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">pw</span><span class="p">.</span><span class="n">letter</span> <span class="o">||</span> <span class="n">pw</span><span class="p">.</span><span class="n">str</span><span class="p">[</span><span class="n">pw</span><span class="p">.</span><span class="n">max</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">pw</span><span class="p">.</span><span class="n">letter</span><span class="p">);</span>
<span class="p">})</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span></code></pre>
</figure>

<p>The only potential issue, and obviously one I stumbled upon and which cost me one minute because of an incorrect answer is that position - of course - starts at 1, not 0 here.</p>

<h2 id="day-3"><a href="https://github.com/philipplenk/adventofcode20/tree/main/03">Day 3</a></h2>

<h3 id="part-1-2">Part 1</h3>

<p>Yeahy, may the ascii art begin! This was the first of a classical kind of 2d grid based puzzles this year! It was also the first problem this year where what little preparation I had done came in handy, having predefined point and vector types.</p>

<p>Given a map consisting of open spaces (represented as ‘.’) and trees(represented as ‘#’), all we had to do was check how often one would hit a tree when going down a certain slope. Beginning in {0,0}, just adding the vector {3,1} until you hit the bottom, count the elements with value #. To ensure you always reach the bottom, the grid extends infinitely to the right, simply looping around in classic pacman fashion - which implemented via a simple % on the x value:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">vec2d</span> <span class="n">direction</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
<span class="n">point2d</span> <span class="n">pos</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">y</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()))</span>
<span class="p">{</span>
	<span class="n">pos</span><span class="p">.</span><span class="n">x</span><span class="o">%=</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
	<span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">pos</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">pos</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="sc">'#'</span><span class="p">)</span>
		<span class="o">++</span><span class="n">count</span><span class="p">;</span>
	
	<span class="n">pos</span><span class="o">+=</span><span class="n">direction</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<h3 id="part-2-2">Part 2</h3>

<p>Part 2 was simply doing the same thing with multiple slopes and multiplying the results. Nothing fancy, just moving the counting to a lambda and a small range-for does the trick:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">d</span><span class="o">:</span> <span class="p">{</span><span class="n">vec2d</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span><span class="n">vec2d</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span><span class="n">vec2d</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span><span class="n">vec2d</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span><span class="n">vec2d</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">}})</span>
	<span class="n">result</span><span class="o">*=</span><span class="n">count_trees</span><span class="p">(</span><span class="n">d</span><span class="p">);</span></code></pre>
</figure>

<h2 id="day-4"><a href="https://github.com/philipplenk/adventofcode20/tree/main/04">Day 4</a></h2>

<h3 id="part-1-3">Part 1</h3>

<p>Given a list of key:value pairs, separated by empty lines, we were first asked to simply check for the presence of various fields. Quite similar to the first day, this was mostly an exercise in getting parsing somewhat right, which, frankly, annoyed me a little at the time. As on that day, I first simply defined a type for the data:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">password_data</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>followed by an overloaded operator»:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">password_data</span><span class="o">&amp;</span> <span class="n">pwd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pwd</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">strm</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="n">line</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">line</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">c</span><span class="o">:</span> <span class="n">line</span><span class="p">)</span>
			<span class="n">strm</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="sc">':'</span><span class="o">?</span><span class="sc">' '</span><span class="o">:</span><span class="n">c</span><span class="p">);</span>
		<span class="n">strm</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">strm</span><span class="o">&gt;&gt;</span><span class="n">name</span><span class="o">&gt;&gt;</span><span class="n">data</span><span class="p">)</span>
		<span class="n">pwd</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">data</span><span class="p">;</span>
		
	<span class="k">if</span><span class="p">(</span><span class="n">pwd</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="n">in</span><span class="p">.</span><span class="n">setstate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">failbit</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">in</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	
	<span class="k">return</span> <span class="n">in</span><span class="p">;</span>
<span class="p">}</span>	</code></pre>
</figure>

<p>We then define what it means to be valid:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="nf">is_valid</span><span class="p">(</span><span class="k">const</span> <span class="n">password_data</span><span class="o">&amp;</span> <span class="n">pwd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="mi">7</span><span class="o">&gt;</span> <span class="n">required</span><span class="p">{</span><span class="s">"byr"</span><span class="p">,</span><span class="s">"iyr"</span><span class="p">,</span><span class="s">"eyr"</span><span class="p">,</span><span class="s">"hgt"</span><span class="p">,</span><span class="s">"hcl"</span><span class="p">,</span><span class="s">"ecl"</span><span class="p">,</span><span class="s">"pid"</span><span class="p">};</span>
	<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">part</span><span class="o">:</span> <span class="n">required</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="n">pwd</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">part</span><span class="p">)</span><span class="o">==</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">pwd</span><span class="p">.</span><span class="n">data</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>and let count_if do all the work:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">count_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">password_data</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},{},</span><span class="n">is_valid</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span></code></pre>
</figure>

<p>The different maps were separated by an empty line in between them, which made it rather tedious (and likely a bad idea) to parse as I did by overloading operator» on std::istream. I also - as usual - committed another ridiculously stupid mistake that cost me a good 5 minutes:</p>

<p>Note how I read lines until either std::getline fails or returns an empty line. That is because there are actually two ways a collection of related key-value pairs is terminated: With an empty line OR with the end of input. The problem occurs in the latter case. If std::getline fails, it sets, appropriately, the std::ios::failbit on the underlying stream. If I do not clear it, however, this indicates to the istream_iterator that extraction failed and the last entry will not be accepted.</p>

<h3 id="part-2-3">Part 2</h3>

<p>Now, in addition to merely checking for their presence, we were tasked with checking each fields validity based on certain criteria. Again, not too difficult, just quite tedious and easy to get wrong, yielding somewhat unsightly code by necessity. Originally, I had a gigantic if-else block and repeated code, just to get it done as quickly as possible(faaar too slow for the leaderboard, of course), but looking at that code was the sort of torture I could not possibly subject my dear readers to, so I went kind of overboard and constructed a bunch of composable function objects that allowed me to define the criteria in an almost declarative style:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="p">)</span><span class="o">&gt;&gt;&gt;</span> <span class="n">field_validator</span>
<span class="p">{</span>
	<span class="p">{</span><span class="s">"byr"</span><span class="p">,</span> <span class="n">all</span><span class="p">(</span><span class="n">is_length</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="n">is_number</span><span class="p">,</span><span class="n">chain</span><span class="p">(</span><span class="n">as_number</span><span class="p">,</span><span class="n">is_between</span><span class="p">(</span><span class="mi">1920</span><span class="p">,</span><span class="mi">2002</span><span class="p">)))},</span>
		
	<span class="p">{</span><span class="s">"iyr"</span><span class="p">,</span> <span class="n">all</span><span class="p">(</span><span class="n">is_length</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="n">is_number</span><span class="p">,</span><span class="n">chain</span><span class="p">(</span><span class="n">as_number</span><span class="p">,</span><span class="n">is_between</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span><span class="mi">2020</span><span class="p">)))},</span>
		
	<span class="p">{</span><span class="s">"eyr"</span><span class="p">,</span> <span class="n">all</span><span class="p">(</span><span class="n">is_length</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="n">is_number</span><span class="p">,</span><span class="n">chain</span><span class="p">(</span><span class="n">as_number</span><span class="p">,</span><span class="n">is_between</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span><span class="mi">2030</span><span class="p">)))},</span>
		
	<span class="p">{</span><span class="s">"hgt"</span><span class="p">,</span> <span class="n">one_of</span>
		<span class="p">(</span>
		<span class="n">all</span><span class="p">(</span><span class="n">ends_with</span><span class="p">(</span><span class="s">"cm"</span><span class="p">),</span><span class="n">chain</span><span class="p">(</span><span class="n">remove_suffix</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">is_number</span><span class="p">),</span><span class="n">chain</span><span class="p">(</span><span class="n">remove_suffix</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">as_number</span><span class="p">,</span><span class="n">is_between</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span><span class="mi">193</span><span class="p">))),</span>
			<span class="n">all</span><span class="p">(</span><span class="n">ends_with</span><span class="p">(</span><span class="s">"in"</span><span class="p">),</span><span class="n">chain</span><span class="p">(</span><span class="n">remove_suffix</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">is_number</span><span class="p">),</span><span class="n">chain</span><span class="p">(</span><span class="n">remove_suffix</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">as_number</span><span class="p">,</span><span class="n">is_between</span><span class="p">(</span><span class="mi">59</span><span class="p">,</span><span class="mi">76</span><span class="p">)))</span>
		<span class="p">)</span>
	<span class="p">},</span>
		
	<span class="p">{</span><span class="s">"ecl"</span><span class="p">,</span> <span class="n">is_one_of</span><span class="p">(</span><span class="s">"amb"</span><span class="p">,</span><span class="s">"blu"</span><span class="p">,</span><span class="s">"brn"</span><span class="p">,</span><span class="s">"gry"</span><span class="p">,</span><span class="s">"grn"</span><span class="p">,</span><span class="s">"hzl"</span><span class="p">,</span><span class="s">"oth"</span><span class="p">)},</span>
	
	<span class="p">{</span><span class="s">"pid"</span><span class="p">,</span> <span class="n">all</span><span class="p">(</span><span class="n">is_length</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span><span class="n">is_number</span><span class="p">)},</span>
	
	<span class="p">{</span><span class="s">"hcl"</span><span class="p">,</span> <span class="n">all</span><span class="p">(</span><span class="n">starts_with</span><span class="p">(</span><span class="s">"#"</span><span class="p">),</span> <span class="n">chain</span><span class="p">(</span><span class="n">remove_prefix</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">is_hexnumber</span><span class="p">))},</span>
<span class="p">};</span></code></pre>
</figure>

<p>The business logic ones are rather trivial and uninteresting. The ones used for composition can, however, prove educational:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">all</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="p">...</span> <span class="n">checkers</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">checkers</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">...);</span> <span class="p">};</span> <span class="p">};</span>
	
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">one_of</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="p">...</span> <span class="n">checkers</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">checkers</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">||</span> <span class="p">...);</span> <span class="p">};</span> <span class="p">};</span>
	
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">chain</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">fun</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">funs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">chain_impl</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">recurse</span><span class="p">,</span> <span class="k">auto</span> <span class="n">fun</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">funs</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="k">constexpr</span><span class="p">(</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">funs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">fun</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">recurse</span><span class="p">(</span><span class="n">recurse</span><span class="p">,</span> <span class="n">funs</span><span class="p">...)(</span><span class="n">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span> <span class="p">};</span>
	<span class="p">};</span>
	
	<span class="k">return</span> <span class="nf">chain_impl</span><span class="p">(</span><span class="n">chain_impl</span><span class="p">,</span><span class="n">fun</span><span class="p">,</span><span class="n">funs</span><span class="p">...);</span>
<span class="p">};</span></code></pre>
</figure>

<p><em>all</em> simply takes a bunch of callables and returns a new callable that utilizes <a href="https://en.cppreference.com/w/cpp/language/fold">C++17’s fold expressions</a> to call each one of the given checkers in a chain connected via &amp;&amp;, i.e. returning true exactly if all of the given checkers would return true.</p>

<p><em>one_of</em> does pretty much the same thing, just with ||, i.e. or, instead of and.</p>

<p><em>chain</em>, as the other two, takes a collection of callables and returns another callable. This one, however, is constructed in a little more complicated fashion. First, we call a helper <em>chain_impl</em>. This is necessary to get recursion, which is otherwise not easily available in lambda expressions. The helper does one of two things:</p>
<ul>
  <li>If there is only one callable left, it is returned.</li>
  <li>Otherwise, we construct a new callable that calls the first one and passes the result on to whatever the recursion will construct for all other functions.</li>
</ul>

<p>Effectively, given functions a, b, c and d, this will construct an expression equivalent to d(c(b(a(input)))), i.e. it chains the calls, using the result of the first as input to the second and so on(similar to the use of <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">pipes</a> in Unix, a | b | c | d).</p>

<h2 id="day-5"><a href="https://github.com/philipplenk/adventofcode20/tree/main/05">Day 5</a></h2>

<h3 id="part-1-4">Part 1</h3>

<p>This one was a bit more interesting and certainly educational. We were given a lovely description of how a certain airliner numbers their seats by repeatedly subdividing a range, throwing away either the lower or the upper half with each incoming letter. Whilst reminiscent of binary search, it is basically even simpler. The description mirrors exactly the classical definition of what a bit actually is: something that halves your prior uncertainty. As such, the strings proved to be nothing more than a fancy encoding for a 10-digit binary number, MSB first. With this realization, completing the task - that of finding the highest id - was trivial:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp">	<span class="k">const</span> <span class="k">auto</span> <span class="n">seat_id</span><span class="o">=</span><span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">c</span><span class="o">:</span> <span class="n">str</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">id</span><span class="o">&lt;&lt;=</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="sc">'B'</span> <span class="o">||</span> <span class="n">c</span><span class="o">==</span><span class="sc">'R'</span><span class="p">)</span>
				<span class="n">id</span><span class="o">|=</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
	<span class="p">};</span>
	
	<span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">max_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">str</span><span class="p">;)</span>
	<span class="p">{</span>
		<span class="n">max_id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max_id</span><span class="p">,</span><span class="n">seat_id</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
	<span class="p">}</span></code></pre>
</figure>

<p>Note how we cannot use <a href="https://en.cppreference.com/w/cpp/algorithm/max_element">max_element</a>, as that sadly requires a <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">forward iterator</a>.</p>

<h3 id="part-2-4">Part 2</h3>

<p>Given the same list, we were now tasked with finding the one and only missing element. The list does not necessarily start or end at the lowest and highest possible id, but our missing element was declared to be somewhere in between.
This could - again - be solved in more than one way, with up and downsides of runtime, memory usage or readability. First, the <a href="https://github.com/philipplenk/adventofcode20/tree/main/05/02_adjacent_find.cpp">more readable solution</a>, at an additional O(n) memory (for storing all ids) and O(n log n) runtime (for sorting them):</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">ids</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},{},</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span><span class="n">seat_id</span><span class="p">);</span>
	
<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">ids</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">adjacent_find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">ids</span><span class="p">),[](</span><span class="k">auto</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">auto</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">rhs</span><span class="o">-</span><span class="n">lhs</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span> <span class="p">})</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span></code></pre>
</figure>

<p>Already pretty decent, but we can do better by knowing and abusing a tiny bit of bit magic, specifically the following lovely properties of the XOR operation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A ^ A == 0
</code></pre></div></div>

<p>I.e. a number xor’ed with itself disappears. Further:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A^B == B^A
</code></pre></div></div>

<p>That is, the operation is commutative, the order in which it is performed does not matter. And finally:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A^0 == A 
</code></pre></div></div>

<p>A number xor’ed with 0 does not change.</p>

<p>All of this can be combined to imply this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(A^B^C^E...) ^ (A^B^C^D^E...)
</code></pre></div></div>

<p>will be equivalent to</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(A^A) ^ (B^B) ^ (C^C) ^ (E^E) ... ^ D
</code></pre></div></div>

<p>meaning the only one left over that is not zeroed will be our missing element! This yields <a href="https://github.com/philipplenk/adventofcode20/tree/main/05/02_xor.cpp">this beautifully efficient solution</a> that no one without knowledge of the trick has any realistic hope to grasp:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">min</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">(),</span> <span class="n">max</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">xored</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">all</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},{},[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">id</span> <span class="o">=</span> <span class="n">seat_id</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
	<span class="n">min</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">,</span><span class="n">id</span><span class="p">);</span>
	<span class="n">max</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">,</span><span class="n">id</span><span class="p">);</span>
	<span class="n">xored</span><span class="o">^=</span><span class="n">id</span><span class="p">;</span>
<span class="p">});</span>
	
<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">i</span><span class="o">=</span><span class="n">min</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">max</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="n">all</span><span class="o">^=</span><span class="n">i</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">xored</span><span class="o">^</span><span class="n">all</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span></code></pre>
</figure>

<p>Knowing the trick, it does seem rather straightforward so and has only constant memory footprint and linear runtime, which is just fabulous ;-)</p>

<p>Accessibility can, however, be somewhat regained whilst not only keeping but even improving ever so slightly on this runtime by recognizing there is a simpler pair of operations with very similar properties: + and -.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A+0 = A

A-A = 0

A+B = B+A
</code></pre></div></div>

<p>Meaning, of course,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(A+B+C+D+E...) - (A+B+C+E...) = (A-A) + (B-B) + (C-C) + D + (E-E)... = D
</code></pre></div></div>

<p>Simply summing all elements and subtracting that sum from what it would be if none were missing yields exactly the one missing element! Knowing <a href="https://www.youtube.com/watch?v=Dd81F6-Ar_0">a bit of history</a> and Gauss’s famous formula for computing the sum of all integers up to a given bound((n*n+n)/2), we can skip the second loop and directly compute the desired sum in closed form:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span> <span class="n">min</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">(),</span> <span class="n">max</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint16_t</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},{},[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">id</span> <span class="o">=</span> <span class="n">seat_id</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
	<span class="n">min</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">,</span><span class="n">id</span><span class="p">);</span>
	<span class="n">max</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">,</span><span class="n">id</span><span class="p">);</span>
	<span class="n">sum</span><span class="o">+=</span><span class="n">id</span><span class="p">;</span>
<span class="p">});</span>
	
<span class="o">--</span><span class="n">min</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">((</span><span class="n">max</span><span class="o">*</span><span class="n">max</span><span class="o">+</span><span class="n">max</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">min</span><span class="o">*</span><span class="n">min</span><span class="o">+</span><span class="n">min</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="n">sum</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span></code></pre>
</figure>

<h2 id="day-6"><a href="https://github.com/philipplenk/adventofcode20/tree/main/06">Day 6</a></h2>

<h3 id="part-1-5">Part 1</h3>

<p>Given a number of “yes-or-no-questions” - each identified by a single character - we were provided with a list of “answers”, i.e. lines containing a character if the corresponding question was answered in the affirmative and not containing it otherwise.</p>

<p>Those answers were separated into groups by empty lines and our first task was to count in how many groups each “question”(i.e. character) was present. We then should return the sum of those counts.</p>

<p>Again - as seems to be a theme in those early days - the most difficult or rather time consuming part here is parsing question and input correctly, with the actual task being simple counting. Here is how I did it:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span><span class="mi">256</span><span class="o">&gt;</span> <span class="n">counts</span><span class="p">{};</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">counts</span><span class="p">[</span><span class="sc">'a'</span><span class="p">],</span> <span class="n">end</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">counts</span><span class="p">[</span><span class="sc">'z'</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	
<span class="k">const</span> <span class="k">auto</span> <span class="n">finish_group</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
<span class="p">{</span>		
	<span class="n">total</span><span class="o">+=</span><span class="n">std</span><span class="o">::</span><span class="n">count_if</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span><span class="n">end</span><span class="p">,[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">v</span><span class="p">){</span> <span class="k">return</span> <span class="n">v</span><span class="o">!=</span><span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
	<span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="p">};</span>
	
<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span><span class="n">line</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="n">finish_group</span><span class="p">();</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">c</span><span class="o">:</span> <span class="n">line</span><span class="p">)</span>
			<span class="o">++</span><span class="n">counts</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">finish_group</span><span class="p">();</span></code></pre>
</figure>

<p>Nothing much to explain here. I simply read the input, line by line, and count the frequency of all characters in an array indexed by the characters value - just like one would do when implementing <a href="https://en.wikipedia.org/wiki/Counting_sort">counting sort</a>. After an empty line, I finalize the group by counting how many entries were not 0 - that means they appeared at least once - and reset the counts.</p>

<p>Using an array to count is, of course, a bit of a waste of space, but I deemed it acceptable as the resulting code is succinct, readable and efficient. It also turned out to be useful for part 2.</p>

<h3 id="part-2-5">Part 2</h3>

<p>The second part did not, in fact, significantly ramp up the difficulty. Instead of counting how often each answer was given in total, we should only count those answers in a group which were given by everyone in it. As I already counted the frequency, all that was left was determining the group size:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp">	<span class="o">++</span><span class="n">group_size</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">c</span><span class="o">:</span> <span class="n">line</span><span class="p">)</span>
		<span class="o">++</span><span class="n">counts</span><span class="p">[</span><span class="n">c</span><span class="p">];</span></code></pre>
</figure>

<p>Followed by simply changing a “!=0” to a “==group_size”:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">finish_group</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
<span class="p">{</span>		
	<span class="n">total</span><span class="o">+=</span><span class="n">std</span><span class="o">::</span><span class="n">count</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">group_size</span><span class="p">);</span>
	<span class="n">group_size</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</figure>

<p>It might have broken if anyone had enthusiastically answered yes more than once on the same question, which, to my great relief, was not the case.</p>

<h2 id="day-7"><a href="https://github.com/philipplenk/adventofcode20/tree/main/07">Day 7</a></h2>

<h3 id="part-1-6">Part 1</h3>

<p>Finally a graph problem! Given a number of bags, all of which containing a number of different bags, first count all that will, in one of those interior ones, contain a “shiny gold” one. Before tackling the more interesting part here, we unfortunately do have to get some annoying parsing out of the way, which - as so frequently - took the bulk of my required time.</p>

<p>Which bags contain how many of which other bags was given as a string of this form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vibrant plum bags contain 5 faded blue bags, 6 dotted black bags.
</code></pre></div></div>

<p>Or sometimes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>faded blue bags contain no other bags.
</code></pre></div></div>

<p>It ought to be trivial, but I am embarrassed to say that this years problems really drove home the point that my skills in the parsing area are severely lacking and I have some serious brushing up to do. Some higher proficiency with regular expressions, for instance, might have tremendously simplified the following abomination I came up with at the time:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">rule</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">r</span><span class="p">.</span><span class="n">own_name</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	<span class="n">r</span><span class="p">.</span><span class="n">can_contain_n</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">,</span> <span class="n">last</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">str</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">!=</span><span class="s">"contain"</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">r</span><span class="p">.</span><span class="n">own_name</span><span class="o">+=</span><span class="n">last</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">str</span><span class="o">+</span><span class="s">" "</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">r</span><span class="p">.</span><span class="n">own_name</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
	
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">in</span><span class="p">;</span>
	
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">n_str</span><span class="p">;</span>
		<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">n_str</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">n_str</span><span class="o">==</span><span class="s">"no"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">str</span><span class="o">&gt;&gt;</span><span class="n">str</span><span class="o">&gt;&gt;</span><span class="n">str</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="n">n</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">n_str</span><span class="p">);</span>
		<span class="k">while</span><span class="p">(</span><span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">str</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">!=</span><span class="sc">','</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">!=</span><span class="sc">'.'</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">name</span><span class="o">+=</span><span class="n">str</span><span class="o">+</span><span class="s">" "</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">name</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="n">r</span><span class="p">.</span><span class="n">can_contain_n</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">!=</span><span class="sc">'.'</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">in</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Don’t look at it too closely. Great! Now that we have this, let’s return to the root of our problem. Or rather the reverse. Interpreting the “contains” relation as edges in a graph, we can have one node for each bag type and an edge to all other bags in which it might be contained:</p>

<p>For instance, this description:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>green bags contain 2 red bags, 2 black bags.
red bags contain 1 blue bag.
blue bags contain 1 shiny gold bag, 3 black bags.
black bags contain no other bags.
shiny gold bags contain 7 gold bags.
</code></pre></div></div>

<p>would yield the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"red" &lt;--------- "blue" &lt;----- "shiny gold" &lt;----- "gold"
  |                ^ 
  v                |
"green"&lt;--"black"__|
</code></pre></div></div>

<p>Thanks to the eldritch horror above, such a reversed graph can be constructed easily, representing it as a map from <em>node-name</em> to <em>list-of-children-names</em>:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">reverse_graph</span><span class="p">;</span>
<span class="n">rule</span> <span class="n">r</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">:</span><span class="n">r</span><span class="p">.</span><span class="n">can_contain_n</span><span class="p">)</span>
	<span class="n">reverse_graph</span><span class="p">[</span><span class="n">name</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">own_name</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</figure>

<p>Given that, all we need to do is walk each possible path away from our starting node (“shiny gold”) and count the total number of nodes we pass by(remembering which we have already seen and counted on the way):</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">left</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">seen</span><span class="p">;</span>
<span class="n">left</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"shiny gold"</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">left</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
	
	<span class="n">left</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> 
	<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">target</span><span class="o">:</span> <span class="n">reverse_graph</span><span class="p">[</span><span class="n">next</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">seen</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">==</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">seen</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">seen</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
			<span class="n">left</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
			<span class="o">++</span><span class="n">count</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<h3 id="part-2-6">Part 2</h3>

<p>Wonderful! Now for part 2 we were tasked with doing basically the reverse. Instead of counting how many different kinds of bags can contain a shiny gold one, we are asked how many bags are contained within. This requires us to consider one more piece of information given in our data, the number telling us how often each kind of bag is contained within. Reversing the edges from part 1 and labeling them with a “cost” representing their quantity yields a graph like this one:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"red" ----1----&gt; "blue" --1--&gt; "shiny gold" ---7--&gt; "gold"
  ^                  | 
  2                  3
  |                  |
"green"-2-&gt;"black"&lt;__|
</code></pre></div></div>

<p>Which we will, once again, simply walk recursively from our starting location, multiplying the results by the given quantities:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">edge</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">weight</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">number_of_interior_bags</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">outer_name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">outer_name</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">==</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
		
	<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">name</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">:</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)</span>
		<span class="n">count</span><span class="o">+=</span><span class="n">n</span><span class="o">*</span><span class="n">number_of_interior_bags</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">graph</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<h2 id="day-8"><a href="https://github.com/philipplenk/adventofcode20/tree/main/08">Day 8</a></h2>

<h3 id="part-1-7">Part 1</h3>

<p>The interesting emulation problems have finally started! I really loved all the intcode problems in 2019, so this was getting my hopes up!</p>

<p>We started out slowly so and should just fix a simple program which executes one of only three types of instructions:</p>

<ul>
  <li>acc, adding to the accumulator</li>
  <li>jmp, a relative jump</li>
  <li>nop, my favorite thing, doing nothing</li>
</ul>

<p>As given, the program contained an infinite loop and we were tasked with determining its state once we enter the loop, i.e. once we execute an instruction for the second time. Without further ado, lets jump right into the code.</p>

<p>First, we define structs for our state and instructions:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">state</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">opcode</span>
<span class="p">{</span>
	<span class="n">acc</span><span class="p">,</span>
	<span class="n">jmp</span><span class="p">,</span>
	<span class="n">nop</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">instruction</span>
<span class="p">{</span>
	<span class="n">opcode</span> <span class="n">op</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">arg</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>Parsing them is thankfully easy:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">instruction</span><span class="o">&amp;</span> <span class="n">ins</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">name</span><span class="o">==</span><span class="s">"acc"</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ins</span><span class="p">.</span><span class="n">op</span><span class="o">=</span><span class="n">opcode</span><span class="o">::</span><span class="n">acc</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">ins</span><span class="p">.</span><span class="n">arg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">name</span><span class="o">==</span><span class="s">"jmp"</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ins</span><span class="p">.</span><span class="n">op</span><span class="o">=</span><span class="n">opcode</span><span class="o">::</span><span class="n">jmp</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">ins</span><span class="p">.</span><span class="n">arg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">name</span><span class="o">==</span><span class="s">"nop"</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ins</span><span class="p">.</span><span class="n">op</span><span class="o">=</span><span class="n">opcode</span><span class="o">::</span><span class="n">nop</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">ins</span><span class="p">.</span><span class="n">arg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">in</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>As is executing them, either adding to the accumulator or adding to the program counter or alternatively doing nothing at all:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">execute</span><span class="p">(</span><span class="k">const</span> <span class="n">instruction</span><span class="o">&amp;</span> <span class="n">ins</span><span class="p">,</span> <span class="n">state</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">ins</span><span class="p">.</span><span class="n">op</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="n">opcode</span><span class="o">::</span><span class="n">acc</span><span class="p">:</span> <span class="n">s</span><span class="p">.</span><span class="n">accumulator</span><span class="o">+=</span><span class="n">ins</span><span class="p">.</span><span class="n">arg</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">opcode</span><span class="o">::</span><span class="n">jmp</span><span class="p">:</span> <span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="o">+=</span><span class="n">ins</span><span class="p">.</span><span class="n">arg</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">opcode</span><span class="o">::</span><span class="n">nop</span><span class="p">:</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>To solve our problem, we first read all instructions into a vector, setup a pristine state with accumulator = pc = 0 and begin executing. 
After each instruction we increment the program counter to determine the next one, whilst keeping track - in a simple hashset - of all positions we have encountered so far. Upon reaching one that was previously seen, we declare the cycle detected and break our loop:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">instruction</span><span class="o">&gt;</span> <span class="n">instructions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">instruction</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},{});</span>

<span class="n">state</span> <span class="n">s</span><span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">seen</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="n">seen</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">)</span><span class="o">==</span><span class="n">seen</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="p">{</span>
	<span class="n">seen</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">);</span>
	<span class="n">execute</span><span class="p">(</span><span class="n">instructions</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">],</span><span class="n">s</span><span class="p">);</span>
	<span class="o">++</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">accumulator</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span></code></pre>
</figure>

<p>Lovely, lets move on to…</p>

<h3 id="part-2-7">Part 2</h3>

<p>Now that we are able to emulate our loop, we are supposed to break it. There is one single nop or jmp instruction that if flipped to the opposite will cause our program to terminate by causing the program counter to reach the end of memory.</p>

<p>The most trivial and perfectly sufficient idea is to simply brute force it. Iterate over every instruction and if it is a jmp or nop, toggle it and try running our program from part 1. If a loop was detected, we try the next one. If not, we have found the instruction to change:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">ins</span><span class="o">:</span> <span class="n">instructions</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ins</span><span class="p">.</span><span class="n">op</span><span class="o">!=</span><span class="n">opcode</span><span class="o">::</span><span class="n">acc</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ins</span><span class="p">.</span><span class="n">op</span><span class="o">=</span><span class="n">ins</span><span class="p">.</span><span class="n">op</span><span class="o">==</span><span class="n">opcode</span><span class="o">::</span><span class="n">jmp</span><span class="o">?</span><span class="n">opcode</span><span class="o">::</span><span class="n">nop</span><span class="o">:</span><span class="n">opcode</span><span class="o">::</span><span class="n">jmp</span><span class="p">;</span>
		<span class="k">auto</span> <span class="p">[</span><span class="n">loop_detected</span><span class="p">,</span> <span class="n">result</span><span class="p">]</span> <span class="o">=</span> <span class="n">detect_loop</span><span class="p">(</span><span class="n">instructions</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">loop_detected</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">result</span><span class="p">.</span><span class="n">accumulator</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ins</span><span class="p">.</span><span class="n">op</span><span class="o">=</span><span class="n">ins</span><span class="p">.</span><span class="n">op</span><span class="o">==</span><span class="n">opcode</span><span class="o">::</span><span class="n">jmp</span><span class="o">?</span><span class="n">opcode</span><span class="o">::</span><span class="n">nop</span><span class="o">:</span><span class="n">opcode</span><span class="o">::</span><span class="n">jmp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>To keep it readable, I outsourced loop detection and gave it a nice, expressive return type:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">execution_result</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">loop_detected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">state</span> <span class="n">final_state</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">execution_result</span> <span class="nf">detect_loop</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">instruction</span><span class="o">&gt;&amp;</span> <span class="n">instructions</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">state</span> <span class="n">s</span><span class="p">{};</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">seen</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="nb">false</span><span class="p">);</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">seen</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="n">seen</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">execute</span><span class="p">(</span><span class="n">instructions</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">],</span><span class="n">s</span><span class="p">);</span>
		<span class="o">++</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="p">{</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">s</span><span class="p">};</span>
<span class="p">}</span></code></pre>
</figure>

<p>Whilst this is perfectly sufficient in our case and terminates within a small fraction of a second even on my old machines, it is not exactly ideal. Worst case, its asymptotic complexity seems quadratic. Consider this example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nop 1
nop 1
nop 1
....
jmp -program_size
</code></pre></div></div>

<p>It would run over each nop, run the complete program to the very end, detect the loop and try the next one. That is, each attempt before the last executes n-1 nop and 2 jmp instructions and we need to do that n-1 times. Quite terrifying. So lets do better:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">reaches_end</span> <span class="o">=</span> <span class="n">compute_end_reachability</span><span class="p">(</span><span class="n">instructions</span><span class="p">);</span>

<span class="n">state</span> <span class="n">s</span><span class="p">{};</span>
<span class="kt">bool</span> <span class="n">changed_one</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">()))</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">changed_one</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">auto</span> <span class="n">target_pc</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="o">+</span><span class="n">instructions</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">].</span><span class="n">arg</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">instructions</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">].</span><span class="n">op</span><span class="o">==</span><span class="n">opcode</span><span class="o">::</span><span class="n">jmp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">reaches_end</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">reaches_end</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="n">instructions</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">].</span><span class="n">op</span><span class="o">=</span><span class="n">opcode</span><span class="o">::</span><span class="n">nop</span><span class="p">;</span>
			<span class="n">changed_one</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">instructions</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">].</span><span class="n">op</span><span class="o">==</span><span class="n">opcode</span><span class="o">::</span><span class="n">nop</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">reaches_end</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">reaches_end</span><span class="p">[</span><span class="n">target_pc</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="n">instructions</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">].</span><span class="n">op</span><span class="o">=</span><span class="n">opcode</span><span class="o">::</span><span class="n">jmp</span><span class="p">;</span>
			<span class="n">changed_one</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">execute</span><span class="p">(</span><span class="n">instructions</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">],</span><span class="n">s</span><span class="p">);</span>
	<span class="o">++</span><span class="n">s</span><span class="p">.</span><span class="n">pc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="p">.</span><span class="n">accumulator</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span></code></pre>
</figure>

<p>Looks a bit more complex than our previous attempt, but the running time turns out to be linear. Allow me to first explain my reasoning:</p>

<p>Assuming we knew for each instruction if beginning execution from it will reach the end, we could execute our code once and simply change the first instruction we encounter that could not reach the end but could if toggled. Doing such a thing would run in linear time, as no loops are entered and each instruction is executed at most once. That is exactly what you see happening in the code above.</p>

<p>This, however, delegates the hard problem to figuring out which instructions can and cannot reach the end:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">compute_jump_sources</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">instruction</span><span class="o">&gt;&amp;</span> <span class="n">instructions</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">jump_sources</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pc</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="o">++</span><span class="n">pc</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">auto</span> <span class="n">target_pc</span> <span class="o">=</span> <span class="n">pc</span><span class="o">+</span><span class="n">instructions</span><span class="p">[</span><span class="n">pc</span><span class="p">].</span><span class="n">arg</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">instructions</span><span class="p">[</span><span class="n">pc</span><span class="p">].</span><span class="n">op</span><span class="o">==</span><span class="n">opcode</span><span class="o">::</span><span class="n">jmp</span> <span class="o">&amp;&amp;</span> <span class="n">target_pc</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">target_pc</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">()))</span>
			<span class="n">jump_sources</span><span class="p">[</span><span class="n">target_pc</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">jump_sources</span><span class="p">;</span>
<span class="p">}</span>
	
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">compute_end_reachability</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">instruction</span><span class="o">&gt;&amp;</span> <span class="n">instructions</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">reaches_end</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">seen</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="nb">false</span><span class="p">);</span>
	
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">jump_sources</span> <span class="o">=</span> <span class="n">compute_jump_sources</span><span class="p">(</span><span class="n">instructions</span><span class="p">);</span>
	
	<span class="k">const</span> <span class="k">auto</span> <span class="n">mark_upward</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">start_pc</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">value</span><span class="p">,</span> <span class="k">auto</span> <span class="n">recurse</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span>
	<span class="p">{</span>		
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">start_pc</span><span class="p">;</span> <span class="n">pc</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">seen</span><span class="p">[</span><span class="n">pc</span><span class="p">];</span> <span class="o">--</span><span class="n">pc</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">const</span> <span class="k">auto</span> <span class="n">target_pc</span> <span class="o">=</span> <span class="n">pc</span><span class="o">+</span><span class="n">instructions</span><span class="p">[</span><span class="n">pc</span><span class="p">].</span><span class="n">arg</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">instructions</span><span class="p">[</span><span class="n">pc</span><span class="p">].</span><span class="n">op</span><span class="o">==</span><span class="n">opcode</span><span class="o">::</span><span class="n">jmp</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">target_pc</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">target_pc</span><span class="o">&gt;=</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">()))</span>
					<span class="n">value</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">seen</span><span class="p">[</span><span class="n">target_pc</span><span class="p">])</span>
					<span class="n">value</span> <span class="o">=</span> <span class="n">reaches_end</span><span class="p">[</span><span class="n">target_pc</span><span class="p">];</span>
				<span class="k">else</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">seen</span><span class="p">[</span><span class="n">pc</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">reaches_end</span><span class="p">[</span><span class="n">pc</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
			
			<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">source</span><span class="o">:</span> <span class="n">jump_sources</span><span class="p">[</span><span class="n">pc</span><span class="p">])</span>
				<span class="n">recurse</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">recurse</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">};</span>
	
	<span class="n">mark_upward</span><span class="p">(</span><span class="n">instructions</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span><span class="n">mark_upward</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">reaches_end</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>I am iterating over all instructions once to determine from where each instruction can be reached(compute_jump_sources). Then I iterate again and mark which instructions can reach the end. Turns out that is not quite so hard either. We have to realize the following simple facts:</p>

<ul>
  <li>A non-jmp instruction can reach the end if it is at the end or if the one following it could reach the end</li>
  <li>A jmp instruction can reach the end if its target is the end or can reach the end</li>
</ul>

<p>As such, we start with the only one we know about - the end - and work our way upwards. If its not a jump, we simply mark it with the previous result. If its a jump and we know about its destination, we continue with the destinations value. If its a jump and we don’t know about its destination, we can’t proceed and break. Furthermore, if the current instruction can be reached by a jump, we recurse and work our way upward from its source, too.</p>

<p>Runtime analysis of this might seem like a mess, but our seen-vector rushes in to save the day: 
There are at most n jump sources in total (as there are at most n jmp instructions), as such recurse can be called at most n times in total), so we have at most n loops.
Each iteration of the loop either breaks or sets a value in the seen vector to true which was not set previously. As each loop can of course only break once, the total number the first can happen is n.
As seen has exactly n elements and we only enter an iteration and set a value if it was not set, the total number the second can happen - over all loops - is also n.</p>

<p>Just lovely, isn’t it?</p>

<h2 id="day-9"><a href="https://github.com/philipplenk/adventofcode20/tree/main/09">Day 9</a></h2>

<h3 id="part-1-8">Part 1</h3>

<p>Surprisingly easy given the previous two assignments, our quest on this day was simply adding up numbers. We were given a list of them and should find the first one that cannot be represented as a sum of two of the 25 preceding ones. The more perceptive of my readers probably realized by now, that in the grand tradition of instructional <a href="https://en.wikipedia.org/wiki/Spiral_approach">spiraling</a>, this is but a slightly more complicated variation of what we did on day 1!</p>

<p>As such, a trivial - yet horrific in time complexity - <a href="https://github.com/philipplenk/adventofcode20/tree/main/09/01_trivial.cpp">solution</a> is to brute force our way through the problem with 3 ugly nested loops:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">i</span><span class="p">;</span><span class="o">++</span><span class="n">k</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>Funnily enough, that is still fast enough and if we analyzed its complexity at university level, we would call it O(n), as 25 is a constant and so is 25^2. 375 * n is still O(n), so we are golden xD. Well, as you might have guessed from my somewhat snappy tone here, I don’t really like that much. We also keep all of our range in memory right now, which could be avoided.</p>

<p>We only need the last 25 numbers, so lets start with that:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">trivial_fixed_ring</span>
<span class="p">{</span>
	<span class="nl">public:</span>
	<span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
	
	<span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">data_</span><span class="p">[</span><span class="n">start_</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
		<span class="n">start_</span><span class="o">%=</span><span class="n">N</span><span class="p">;</span>
		
	<span class="p">}</span>
	
	<span class="k">auto</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">data_</span><span class="p">[(</span><span class="n">start_</span><span class="o">+</span><span class="n">idx</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">];</span>
	<span class="p">}</span>
	
	<span class="k">auto</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">data_</span><span class="p">[(</span><span class="n">start_</span><span class="o">+</span><span class="n">idx</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">];</span>
	<span class="p">}</span>
	
	<span class="k">auto</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">N</span><span class="p">;</span> <span class="p">}</span>
	
	<span class="k">private</span><span class="o">:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">data_</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">start_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>Yeah, as there is none in the standard library<sup id="fnref:ring" role="doc-noteref"><a href="#fn:ring" class="footnote" rel="footnote">9</a></sup>, implementing a small, bad and severely broken ring buffer might be ever so slight overkill, considering the input list is a mere 1000 numbers and the approach above runs in the fraction of a fraction of a fraction of a second, but who am I if not one to always entertain the notion of severely overengineering the most trivial of tasks?</p>

<p>Utilizing this data structure, our solution changes to look like this:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
<span class="n">trivial_fixed_ring</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">n</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},</span><span class="n">n</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>

<span class="kt">int</span> <span class="n">next</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">==</span><span class="n">next</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	
	<span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">next</span><span class="p">;</span></code></pre>
</figure>

<p>Our theoretical runtime can be reduced by using the exact same methods employed on day 1: either via sorting or via wasting a potentially huge amount of memory.</p>

<p>Let’s do <a href="https://github.com/philipplenk/adventofcode20/tree/main/09/01_sort.cpp">sorting first</a>. We can’t sort in place, as the original order dictates which elements will be replaced in succeeding steps, which is why we have to copy them into an additional buffer first:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">n</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">partial_sort_copy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span></code></pre>
</figure>

<p>We then walk this buffer once, binary-searching for the missing element:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">v</span><span class="o">:</span> <span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">binary_search</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span><span class="n">next</span><span class="o">-</span><span class="n">v</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span></code></pre>
</figure>

<p>Lovely, isn’t it? We reduced our complexity down to O(n) * O(25 log 25), which is, asymptotically speaking, completely irrelevant. If the constant were ever increased, however, it could prove useful to reduce it even further.</p>

<p>Last time, we had a convenient constraint on how big our numbers could get, which was completely thrown out for this task. Numbers here can - and apparently do - get arbitrarily big, so its kind of impossible to allocate a big enough array in advance. Whilst we could determine this number in linear time(by simply scanning the input once and saving max and min values), a simple bitset won’t do, as our sliding window might contain more than one copy of the same value and we have to keep track of when all of those fall out of the window, i.e. we have to count. Considering my solution was &gt;20 million, keeping one integer for each <em>possible</em> one in the input constitutes unfathomable abuse of memory even for the likes of me, so I bailed out and decided on using a hashmap instead, which will - at least on average - still provide me with O(1)-ish access time:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">seen</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">v</span><span class="o">:</span> <span class="n">data</span><span class="p">)</span> <span class="o">++</span><span class="n">seen</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">next</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">v</span><span class="o">:</span> <span class="n">data</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">seen</span><span class="p">[</span><span class="n">next</span><span class="o">-</span><span class="n">v</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	
	<span class="o">--</span><span class="n">seen</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
	<span class="o">++</span><span class="n">seen</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
	<span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</figure>

<h3 id="part-2-8">Part 2</h3>

<p>Surprisingly even easier than part 1 this time. Take the number we just obtained and find a contiguous set of size&gt;2 in our data that sums to it. We can do this easily by keeping a running set, always adding the next number and - if we ever run over our target - erase from the start until we are &lt;= to it again:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},{});</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sum</span><span class="o">+=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">while</span><span class="p">(</span><span class="n">sum</span><span class="o">&gt;</span><span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">min</span><span class="o">&lt;</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">sum</span><span class="o">-=</span><span class="n">data</span><span class="p">[</span><span class="n">min</span><span class="p">];</span>
		<span class="o">++</span><span class="n">min</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">sum</span><span class="o">==</span><span class="n">target</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">auto</span> <span class="p">[</span><span class="n">min_it</span><span class="p">,</span><span class="n">max_it</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">min</span><span class="p">],</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">min_it</span><span class="o">+*</span><span class="n">max_it</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<h2 id="day-10"><a href="https://github.com/philipplenk/adventofcode20/tree/main/10">Day 10</a></h2>

<h3 id="part-1-9">Part 1</h3>

<p>Travel power adapters, oh my. The cover story is a cute one, but the actual problem is rather straightforward. Given a number of “joltage” adapters output values, connectable if they are between 1 and 3 apart and the second is higher than the first, figure out how often they are apart by 1 and how often they are apart by 3 if all were connected together. Since we never can connect a higher to a lower adapter, we simply sort and count the difference between every two elements:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">jolts</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">jolts</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">jolts</span><span class="p">));</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">diff1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">diff3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">jolts</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">jolts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">last</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">diff</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
		<span class="o">++</span><span class="n">diff1</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">diff</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span>
		<span class="o">++</span><span class="n">diff3</span><span class="p">;</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">jolts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">diff1</span><span class="o">*</span><span class="p">(</span><span class="n">diff3</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span></code></pre>
</figure>

<h3 id="part-2-9">Part 2</h3>

<p>That was ever so slightly more difficult. My first hunch was a simple recursive solution, counting the options:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">count_options</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;&amp;</span> <span class="n">jolts</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">last_jolt</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">next_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">begin_jolt</span> <span class="o">=</span> <span class="n">last_jolt</span><span class="p">;</span>
	
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="n">next_idx</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">jolts</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">auto</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">jolts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">last_jolt</span><span class="p">;</span>
		
		<span class="k">if</span><span class="p">(</span><span class="n">diff</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			
		<span class="k">if</span><span class="p">(</span><span class="n">diff</span><span class="o">&lt;</span><span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">jolts</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">result</span><span class="o">+=</span><span class="n">count_options</span><span class="p">(</span><span class="n">jolts</span><span class="p">,</span><span class="n">last_jolt</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">cache</span><span class="p">);</span>
		
		<span class="n">last_jolt</span> <span class="o">=</span> <span class="n">jolts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">result</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Turns out that is not ideal for a number of reasons, most obvious among them is runtime and repeated work. If, for instance, we skip the first adapter and take the second and third on one path, whilst we take the first, skip the second and take the third, the total may be different, but what follows afterwards is exactly the same. Nonetheless, the code above will compute this twice. Every subpath can be reached in a multitude of ways and I recompute it every. single. time. Let’s fix that:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">count_options</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;&amp;</span> <span class="n">jolts</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">last_jolt</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">next_idx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;&amp;</span> <span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">cache</span><span class="p">.</span><span class="n">find</span><span class="p">({</span><span class="n">last_jolt</span><span class="p">,</span><span class="n">next_idx</span><span class="p">});</span><span class="n">it</span><span class="o">!=</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">cache</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
		
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">begin_jolt</span> <span class="o">=</span> <span class="n">last_jolt</span><span class="p">;</span>
	
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="n">next_idx</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">jolts</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">auto</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">jolts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">last_jolt</span><span class="p">;</span>
		
		<span class="k">if</span><span class="p">(</span><span class="n">diff</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			
		<span class="k">if</span><span class="p">(</span><span class="n">diff</span><span class="o">&lt;</span><span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">jolts</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">result</span><span class="o">+=</span><span class="n">count_options</span><span class="p">(</span><span class="n">jolts</span><span class="p">,</span><span class="n">last_jolt</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">cache</span><span class="p">);</span>
		
		<span class="n">last_jolt</span> <span class="o">=</span> <span class="n">jolts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">cache</span><span class="p">[{</span><span class="n">begin_jolt</span><span class="p">,</span><span class="n">next_idx</span><span class="p">}]</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>I employed the time honored tradition of slapping a cache onto my recursion to avoid duplicating work. This turns out to be more than fast enough for our problem and a result is available within the fraction of a second again. Nonetheless, we could have done even better, even if I failed to figure that one out myself in the heat of the moment. It was pointed out to me on the <a href="https://www.includecpp.org/discord/">#include discord</a> and is visible in <a href="https://gitlab.com/stephanroslen/aoc2020/-/blob/master/day10/main.cpp">this solution</a>. Instead of going forward and counting what could follow, we can - true to the spirit of <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a> - go backward and count the pathes we have already seen. Basically the same idea, but we can save the hashmap and know ahead of time how many entries we will need.</p>

<p>Wonderful, but checking <a href="https://www.reddit.com/r/adventofcode/comments/kabi91/2020_day_10_closedform_mathematical_solution/">the lovely reddit</a>, you will figure out there is an even better, if far more mathy<sup id="fnref:mathy" role="doc-noteref"><a href="#fn:mathy" class="footnote" rel="footnote">10</a></sup> and slightly less intuitive way running in what is apparently linear time. Turns out there is a connection to the <a href="https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers">tribonacci sequence</a>.</p>

<p>That was fun and I almost got near the global leaderboard for once, rank 508, my best so far this year.)</p>

<h2 id="day-11"><a href="https://github.com/philipplenk/adventofcode20/tree/main/11">Day 11</a></h2>

<h3 id="part-1-10">Part 1</h3>

<p><a href="https://en.wikipedia.org/wiki/Cellular_automaton">Cellular automata</a>! Quite fitting, to honor <a href="https://en.wikipedia.org/wiki/John_Horton_Conway">John Conway’s</a> legacy - in the sad year of his passing - with another one of those. The cover story here is about seats and people admirably practicing social distancing. If they have too many neighbors, they move away. Given an initial state and a simple set of rules, we had to simulate the seating constellations until they reach a stable, unchanging state.
Rather straightforward, so edges, corners and the fact that all cells update simultaneously always complicates issues slightly. Here is one update step:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">vec2d</span><span class="p">,</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">directions</span><span class="p">{{{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},{</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">},{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">}}};</span>
		
<span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">grid</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">foreach_in_square</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="n">grid_width</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">grid_height</span><span class="o">-</span><span class="mi">1</span><span class="p">},[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="sc">'.'</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">adjacent_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">d</span><span class="o">:</span> <span class="n">directions</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="n">d</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">x</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">target</span><span class="p">.</span><span class="n">x</span><span class="o">&lt;</span><span class="n">grid_width</span> <span class="o">&amp;&amp;</span> <span class="n">target</span><span class="p">.</span><span class="n">y</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">target</span><span class="p">.</span><span class="n">y</span><span class="o">&lt;</span><span class="n">grid_height</span><span class="p">)</span>
			<span class="n">adjacent_count</span><span class="o">+=</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">target</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">target</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="sc">'#'</span><span class="p">);</span>
	<span class="p">}</span>
		
	<span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="sc">'L'</span> <span class="o">&amp;&amp;</span> <span class="n">adjacent_count</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">next</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'#'</span><span class="p">;</span>
		<span class="n">changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="sc">'#'</span> <span class="o">&amp;&amp;</span> <span class="n">adjacent_count</span><span class="o">&gt;=</span><span class="mi">4</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">next</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'L'</span><span class="p">;</span>
		<span class="n">changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">});</span>
	
<span class="n">grid</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span></code></pre>
</figure>

<p>We create a copy of all cells, and iterate over all coordinates. For each of those we iterate over all valid neighbors and count how many of them are occupied, setting the new value in our copy according to the given rules. We can’t set it in our current grid, as all cells should act as if they updated simultaneously and modifying the grid step by step would change results for later processed cells which contain already updated ones as neighbors.</p>

<h3 id="part-2-10">Part 2</h3>

<p>The difficulty was increased ever so slightly by not only considering direct neighbors but everything within ones line of sight. Nothing a simple loop can’t solve, thankfully:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">d</span><span class="o">:</span> <span class="n">directions</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="n">d</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">x</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">target</span><span class="p">.</span><span class="n">x</span><span class="o">&lt;</span><span class="n">grid_width</span> <span class="o">&amp;&amp;</span> <span class="n">target</span><span class="p">.</span><span class="n">y</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">target</span><span class="p">.</span><span class="n">y</span><span class="o">&lt;</span><span class="n">grid_height</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">target</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">target</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="sc">'#'</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="o">++</span><span class="n">adjacent_count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">target</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">target</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="sc">'L'</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
					
		<span class="n">target</span><span class="o">+=</span><span class="n">d</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<h2 id="day-12"><a href="https://github.com/philipplenk/adventofcode20/tree/main/12">Day 12</a></h2>

<h3 id="part-1-11">Part 1</h3>

<p>Given a number of instructions for moving a ship around on a simple 2 dimensional coordinate system (but with cardinal directions), we had to correctly determine which position we end up in. The minor difficulty arises from some directions not being absolute, but relative to the ships current orientation, which we also have to keep track of. Let’s not get ahead of ourselves and first declare the possible instructions and define how they are parsed:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">enum</span> <span class="k">class</span> <span class="nc">type</span>
<span class="p">{</span>
	<span class="n">turn_left</span><span class="p">,</span>
	<span class="n">turn_right</span><span class="p">,</span>
	<span class="n">move_forward</span><span class="p">,</span>
	<span class="n">move</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">instruction</span>
<span class="p">{</span>
	<span class="n">type</span> <span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">step</span><span class="p">;</span>
	<span class="n">vec2d</span> <span class="n">direction</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">instruction</span><span class="o">&amp;</span> <span class="n">ins</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="sc">'N'</span><span class="p">:</span> <span class="n">ins</span><span class="p">.</span><span class="n">t</span><span class="o">=</span><span class="n">type</span><span class="o">::</span><span class="n">move</span><span class="p">;</span> <span class="n">ins</span><span class="p">.</span><span class="n">direction</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'E'</span><span class="p">:</span> <span class="n">ins</span><span class="p">.</span><span class="n">t</span><span class="o">=</span><span class="n">type</span><span class="o">::</span><span class="n">move</span><span class="p">;</span> <span class="n">ins</span><span class="p">.</span><span class="n">direction</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'W'</span><span class="p">:</span> <span class="n">ins</span><span class="p">.</span><span class="n">t</span><span class="o">=</span><span class="n">type</span><span class="o">::</span><span class="n">move</span><span class="p">;</span> <span class="n">ins</span><span class="p">.</span><span class="n">direction</span><span class="o">=</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'S'</span><span class="p">:</span> <span class="n">ins</span><span class="p">.</span><span class="n">t</span><span class="o">=</span><span class="n">type</span><span class="o">::</span><span class="n">move</span><span class="p">;</span> <span class="n">ins</span><span class="p">.</span><span class="n">direction</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'F'</span><span class="p">:</span> <span class="n">ins</span><span class="p">.</span><span class="n">t</span><span class="o">=</span><span class="n">type</span><span class="o">::</span><span class="n">move_forward</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'R'</span><span class="p">:</span> <span class="n">ins</span><span class="p">.</span><span class="n">t</span><span class="o">=</span><span class="n">type</span><span class="o">::</span><span class="n">turn_right</span><span class="p">;</span> <span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="o">/=</span><span class="mi">90</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'L'</span><span class="p">:</span> <span class="n">ins</span><span class="p">.</span><span class="n">t</span><span class="o">=</span><span class="n">type</span><span class="o">::</span><span class="n">turn_left</span><span class="p">;</span> <span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="o">/=</span><span class="mi">90</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">default</span><span class="o">:</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">in</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>I already did some minimal preprocessing here. For one, I chose to save the directions as 2d vectors for easier addition.</p>

<p>Furthermore, I noticed all turns happened in multiples of 90 degree, so instead of saving the angles, I remembered how many 90 degree turns they correspond to. 90 degree turns are easy:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">vec2d</span> <span class="nf">turn_left</span><span class="p">(</span><span class="n">vec2d</span> <span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">old</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">old</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
	<span class="n">old</span><span class="p">.</span><span class="n">y</span><span class="o">=-</span><span class="n">old</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vec2d</span> <span class="nf">turn_right</span><span class="p">(</span><span class="n">vec2d</span> <span class="n">old</span><span class="p">)</span>
<span class="p">{</span>	
	<span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">old</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">old</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
	<span class="n">old</span><span class="p">.</span><span class="n">x</span><span class="o">=-</span><span class="n">old</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Whilst it could maybe have been solved more elegantly with complex multiplication, this works perfectly fine for now so and I really like the clarity of this code which is readable without much of a mathematical background (although it’s always nice to have that nonetheless).</p>

<p>Given this scaffolding, all that is left is iterating over the instructions and modifying either position or direction accordingly:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">instruction</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">},{},[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">ins</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">ins</span><span class="p">.</span><span class="n">t</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="n">type</span><span class="o">::</span><span class="n">move</span><span class="p">:</span> <span class="n">pos</span><span class="o">+=</span><span class="n">ins</span><span class="p">.</span><span class="n">direction</span><span class="o">*</span><span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">type</span><span class="o">::</span><span class="n">turn_left</span><span class="p">:</span> <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">current_direction</span> <span class="o">=</span> <span class="n">turn_left</span><span class="p">(</span><span class="n">current_direction</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">type</span><span class="o">::</span><span class="n">turn_right</span><span class="p">:</span> <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">current_direction</span> <span class="o">=</span> <span class="n">turn_right</span><span class="p">(</span><span class="n">current_direction</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">type</span><span class="o">::</span><span class="n">move_forward</span><span class="p">:</span> <span class="n">pos</span><span class="o">+=</span><span class="n">current_direction</span><span class="o">*</span><span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">});</span></code></pre>
</figure>

<h3 id="part-2-11">Part 2</h3>

<p>Part 2 on this day was nearly identical, only the “move”-instructions were changed to not move the ship directly but modify its movement vector instead, which was applied on the “move-forward” command. The turn commands were also changed to turn the movement vector. Again, it could have been simplified with complex numbers, but worked out fine with my trivialized approach, the only change being one case of instruction handling:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">switch</span><span class="p">(</span><span class="n">ins</span><span class="p">.</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">case</span> <span class="n">type</span><span class="o">::</span><span class="n">move</span><span class="p">:</span> <span class="n">waypoint</span><span class="o">+=</span><span class="n">ins</span><span class="p">.</span><span class="n">direction</span><span class="o">*</span><span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">type</span><span class="o">::</span><span class="n">turn_left</span><span class="p">:</span> <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">waypoint</span> <span class="o">=</span> <span class="n">turn_left</span><span class="p">(</span><span class="n">waypoint</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">type</span><span class="o">::</span><span class="n">turn_right</span><span class="p">:</span> <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">waypoint</span> <span class="o">=</span> <span class="n">turn_right</span><span class="p">(</span><span class="n">waypoint</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">type</span><span class="o">::</span><span class="n">move_forward</span><span class="p">:</span> <span class="n">pos</span><span class="o">+=</span><span class="n">waypoint</span><span class="o">*</span><span class="n">ins</span><span class="p">.</span><span class="n">step</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<h2 id="day-13"><a href="https://github.com/philipplenk/adventofcode20/tree/main/13">Day 13</a></h2>

<h3 id="part-1-12">Part 1</h3>

<p>Given a starting time and a number of bus ids - which also represented their round trip time - we were tasked with finding the first bus to arrive at or after the starting time. For this one, all busses started out at 0, meaning we only had determine the first multiple of each id &gt;= the starting time and choose the minimum of those. To do so, we compute the ceil(i.e. rounded up) result of dividing the starting time by id and subsequently multiply id by that result:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="n">min_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
<span class="kt">long</span> <span class="n">best_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">id</span><span class="o">:</span><span class="n">ids</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">next_factor</span> <span class="o">=</span> <span class="n">first_timestamp</span><span class="o">/</span><span class="n">id</span> <span class="o">+</span> <span class="p">(</span><span class="n">first_timestamp</span><span class="o">%</span><span class="n">id</span><span class="o">!=</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">next_factor</span> <span class="o">*</span> <span class="n">id</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">ts</span><span class="o">&lt;</span><span class="n">min_time</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">best_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
		<span class="n">min_time</span> <span class="o">=</span> <span class="n">ts</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<h3 id="part-2-12">Part 2</h3>

<p>It really pays off to know a tiny bit of linear algebra from time to time ;-) Without it, this one would be really, really hard.</p>

<p>Given not only the periods, but a desired offset for each id, we had to determine the first time satisfying for which each bus arrived exactly its offset later. In other words, we had to solve a series of equations of the form</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = -a mod id0
x = -b mod id1
x = -c mod id2...
</code></pre></div></div>

<p>That is a case for the <a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">famous Chinese remainder theorem</a>!</p>

<p>As such, we first need a way to compute <a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse">modular multiplicative inverses</a>, which can be done with <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">the extended euclidean algorithm</a>:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="nf">multiplicative_inverse</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">old_r</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">old_s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">r</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">auto</span> <span class="n">quotient</span> <span class="o">=</span> <span class="n">old_r</span><span class="o">/</span><span class="n">r</span><span class="p">;</span>
		
		<span class="k">auto</span> <span class="n">new_r</span> <span class="o">=</span> <span class="n">old_r</span><span class="o">-</span><span class="n">quotient</span><span class="o">*</span><span class="n">r</span><span class="p">;</span>
		<span class="k">auto</span> <span class="n">new_s</span> <span class="o">=</span> <span class="n">old_s</span><span class="o">-</span><span class="n">quotient</span><span class="o">*</span><span class="n">s</span><span class="p">;</span>
		
		<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">old_r</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">new_r</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">old_s</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">new_s</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">old_s</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">old_s</span><span class="o">+=</span><span class="n">b</span><span class="p">;</span>
		
	<span class="k">return</span> <span class="n">old_s</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>For each id, we compute the modular inverse of it with the product of all others and multiply it with that product and the desired offset. Our result is the sum of doing that for each id, modulo the product of all ids. Unfortunately, the offsets are negative in our case and modulo with negative numbers is - ummm - <a href="https://stackoverflow.com/questions/7594508/modulo-operator-with-negative-values">let’s say <em>special</em></a> in C++, so I used an expensive loop instead:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">id</span><span class="o">:</span><span class="n">ids</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">mod_product</span><span class="o">/</span><span class="n">id</span><span class="p">.</span><span class="n">mod</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">inverse</span> <span class="o">=</span> <span class="n">multiplicative_inverse</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span><span class="n">id</span><span class="p">.</span><span class="n">mod</span><span class="p">);</span>
	
	<span class="k">auto</span> <span class="n">off</span> <span class="o">=</span> <span class="o">-</span><span class="n">id</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">off</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">off</span><span class="o">+=</span><span class="n">id</span><span class="p">.</span><span class="n">mod</span><span class="p">;</span>

	<span class="n">result</span><span class="o">+=</span><span class="n">off</span><span class="o">*</span><span class="n">mod</span><span class="o">*</span><span class="n">inverse</span><span class="p">;</span>
	<span class="n">result</span><span class="o">%=</span><span class="n">mod_product</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<h2 id="day-14"><a href="https://github.com/philipplenk/adventofcode20/tree/main/14">Day 14</a></h2>

<h3 id="part-1-13">Part 1</h3>

<p>This time, we were supposed to trace modified writes to a special memory. Whenever a value is written, it is first modified based on a simple bitmap by either setting the bits to 0 or 1 or alternatively, leaving them as they were in case of an X. For example, given the following input:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mask = XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
mem[8] = 11
</code></pre></div></div>

<p>memory at address 8 should obtain the value 1011 (i.e. binary 11), but adding a 1 bit at the 7th position and changing the 1 at the second one to a zero: 1001001 (which is 73 in decimal).</p>

<p>My implementation simply constructed two masks, one to &amp;(representing the X’s) and one to |(representing everything else), for those operations:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">update_mask</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">new_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mask_and</span> <span class="o">=</span> <span class="n">mask_or</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">new_mask</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span><span class="n">it</span><span class="o">!=</span><span class="n">new_mask</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span><span class="o">++</span><span class="n">it</span><span class="p">,</span> <span class="o">++</span><span class="n">shift</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">mask_and</span> <span class="o">|=</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="o">==</span><span class="sc">'X'</span><span class="o">?</span><span class="mi">1ll</span><span class="o">:</span><span class="mi">0ll</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">;</span>
		<span class="n">mask_or</span> <span class="o">|=</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="o">==</span><span class="sc">'1'</span><span class="o">?</span><span class="mi">1ll</span><span class="o">:</span><span class="mi">0ll</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span></code></pre>
</figure>

<p>Which were then applied to modify assignments:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>memory[addr] = (value&amp;mask_and) | mask_or;	
</code></pre></div></div>

<p>As the address range was 36 bits and as such incredibly huge, whilst only a small number of cells could actually be used, I chose to represent it as a hashmap:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp">	<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">memory</span><span class="p">;</span></code></pre>
</figure>

<h3 id="part-2-13">Part 2</h3>

<p>Same input, same mask, but very different interpretation. Now an X does not mean the given value, but any possible one, meaning we will have to iterate over all combinations. Furthermore, 0 means to leave the input untouched(the role previously occupied by X), whilst we modify the address written to, not the value. As a first step, we now create 3 masks(one to set to 1, one to leave untouched and one to try all combinations on):</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">update_mask</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">new_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mask_and</span> <span class="o">=</span> <span class="n">mask_or</span> <span class="o">=</span> <span class="n">mask_float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">new_mask</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span><span class="n">it</span><span class="o">!=</span><span class="n">new_mask</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span><span class="o">++</span><span class="n">it</span><span class="p">,</span> <span class="o">++</span><span class="n">shift</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">mask_and</span> <span class="o">|=</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="o">==</span><span class="sc">'X'</span><span class="o">?</span><span class="mi">0ull</span><span class="o">:</span><span class="mi">1ull</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">;</span>
		<span class="n">mask_or</span> <span class="o">|=</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="o">==</span><span class="sc">'1'</span><span class="o">?</span><span class="mi">1ull</span><span class="o">:</span><span class="mi">0ull</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">mask_float</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">mask_and</span><span class="p">)</span><span class="o">&amp;</span><span class="p">((</span><span class="mi">1ull</span><span class="o">&lt;&lt;</span><span class="mi">36</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</figure>

<p>Listing all options might seem complicated at first, but luckily for us, our languages and computers already have a beautiful system to iterate over all combinations of 0 and 1 for a given number of those strung together: counting! So we do just that and simply shift the relevant bits into their desired places afterwards:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">foreach_address</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">,</span> <span class="k">auto</span> <span class="n">fun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span><span class="o">&amp;</span><span class="n">mask_and</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask_or</span><span class="p">;</span>
	
	<span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">set_bits</span> <span class="o">=</span> <span class="n">ptl</span><span class="o">::</span><span class="n">popcount</span><span class="p">(</span><span class="n">mask_float</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="mi">1ull</span><span class="o">&lt;&lt;</span><span class="n">set_bits</span><span class="p">);</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">auto</span> <span class="n">addr_cpy</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="k">auto</span> <span class="n">mask_cpy</span> <span class="o">=</span> <span class="n">mask_float</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">set_bits</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">const</span> <span class="k">auto</span> <span class="n">bitpos</span> <span class="o">=</span> <span class="n">ptl</span><span class="o">::</span><span class="n">countr_zero</span><span class="p">(</span><span class="n">mask_cpy</span><span class="p">);</span>
			<span class="n">mask_cpy</span><span class="o">&amp;=~</span><span class="p">(</span><span class="mi">1ull</span><span class="o">&lt;&lt;</span><span class="n">bitpos</span><span class="p">);</span>
			<span class="n">addr_cpy</span><span class="o">|=</span><span class="p">((</span><span class="n">i</span><span class="o">&gt;&gt;</span><span class="n">j</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1ull</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">bitpos</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="n">fun</span><span class="p">(</span><span class="n">addr_cpy</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span></code></pre>
</figure>

<p>To count bits and determine bit positions, I would have loved to use standard functions, but the <a href="https://en.cppreference.com/w/cpp/header/bit">bit header</a> is only available from C++20 onwards and I was using C++17 only here. As such, I substituted my own inferior version created for <a href="https://github.com/philipplenk/paulchen332">my chess engine, paulchen332</a>.</p>

<h2 id="day-15"><a href="https://github.com/philipplenk/adventofcode20/tree/main/15">Day 15</a></h2>

<h3 id="part-1-14">Part 1</h3>

<p>Let’s play a number game. We start of by reading a bunch of given numbers and remembering the previous two times they were said. Now, after they were read once, the next number depends on the previous one. If it was spoken for the first time, we speak 0. Otherwise, we speak the difference between the last two times it was spoken. That is all. Our task was to determine the 2020th number spoken. Rather cryptic instructions to read and it took me a few minutes to comprehend what was asked of us, but once that fog had cleared, a solution is rather trivial. First define what we have to remember for each spoken number and a hashmap storing this piece of information:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">diff</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">diff</span><span class="o">&gt;</span> <span class="n">last_spoken</span><span class="p">;</span></code></pre>
</figure>

<p>And then simply simulate the process exactly as given:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2020</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">last_spoken</span><span class="p">[</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">};</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">last_spoken</span><span class="p">[</span><span class="n">last</span><span class="p">];</span>
		<span class="k">const</span> <span class="k">auto</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">last</span><span class="o">-</span><span class="n">data</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
		
		<span class="k">if</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">last_spoken</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">dist</span><span class="p">);</span> <span class="n">it</span><span class="o">==</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">last_spoken</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">auto</span><span class="o">&amp;</span> <span class="n">to_change_data</span> <span class="o">=</span> <span class="n">last_spoken</span><span class="p">[</span><span class="n">dist</span><span class="p">];</span>
			
			<span class="n">to_change_data</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">to_change_data</span><span class="p">.</span><span class="n">last</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="k">auto</span><span class="o">&amp;</span> <span class="n">to_change_data</span> <span class="o">=</span> <span class="n">last_spoken</span><span class="p">[</span><span class="n">dist</span><span class="p">];</span>
			
			<span class="n">to_change_data</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">to_change_data</span><span class="p">.</span><span class="n">last</span><span class="p">;</span>
			<span class="n">to_change_data</span><span class="p">.</span><span class="n">last</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<h3 id="part-2-14">Part 2</h3>

<p>Nothing changed, we are just asked for a significantly higher number of turns. Seems difficult at first, but I took the lucky shot and tested if my previous solution worked fast enough and it turns out it completed within 8 seconds with a correct result, jumping in leaderboard position from 1700-ish to 500-ish(far from global again, of course). Nonetheless, I was certain we can do better here.</p>

<p>The first trick I could think of, as it appeared occasionally in problems of this kind, is detecting cycles, so I tried this and it turns out, at least for my numbers and my bound, there was no cycle ;_; So we had to get smarter than that… aaand after far too much time spent on my own attempts I began to google and figured out that:</p>

<ol>
  <li>Given the right starting conditions it is actually a named sequence with an entry in the <a href="https://oeis.org/A181391">OEOIS</a></li>
  <li>There is a <a href="https://www.youtube.com/watch?v=etMJxB-igrc">numberphile video about it</a>, which I highly recommend watching. And - of course:</li>
  <li>There is no known way to get at the entries faster than brute force. So anything that is asymptotically better than what I wrote for part 1 would be a minor mathematical breakthrough ;-)</li>
</ol>

<p>As such, all I could do was optimize what I was already doing. The first and most obvious choice is cutting down on unnecessary allocations, by preallocating enough elements into my hashmap:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">last_spoken</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">30000000</span><span class="p">);</span></code></pre>
</figure>

<p>This cut the runtime down to 5 seconds, which is quite a decent improvement for one line. Switching from a hashmap to a simple vector of 30000000 elements brought another similar improvement, getting the time down to just 2 seconds, switching the type saved from a wasteful std::size_t to int reduced it to 1.5 seconds. In the process, I also made my code look significantly more compact and beautiful than the horrid mess I showed you for part 1:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">30000000</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">last_spoken</span><span class="p">[</span><span class="n">last</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">last</span><span class="o">-</span><span class="n">data</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
	
	<span class="k">auto</span><span class="o">&amp;</span> <span class="n">to_change_data</span> <span class="o">=</span> <span class="n">last_spoken</span><span class="p">[</span><span class="n">dist</span><span class="p">];</span>
		
	<span class="n">to_change_data</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">to_change_data</span><span class="p">.</span><span class="n">seen</span><span class="o">?</span><span class="n">to_change_data</span><span class="p">.</span><span class="n">last</span><span class="o">:</span><span class="n">i</span><span class="p">;</span>
	<span class="n">to_change_data</span><span class="p">.</span><span class="n">last</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">to_change_data</span><span class="p">.</span><span class="n">seen</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Hacking around a tiny bit more to get a more compact memory layout by stealing a bit from “last” instead of having a separate variable for “seen” got the time down to about 1 second, at which point I stopped bothering.</p>

<h2 id="day-16"><a href="https://github.com/philipplenk/adventofcode20/tree/main/16">Day 16</a></h2>

<h3 id="part-1-15">Part 1</h3>

<p>More data validation, yeahy! *sigh*</p>

<p>We have a bunch of tickets with a number of fields, all identified in a language we do not understand. Luckily for us, we also know which fields have to follow which rules, so we might have a shot at ordering them. But first, let’s make sure our data is valid by identifying fields that cannot be valid for any rule and count them.</p>

<p>Rules are given in the form</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class: 1-3 or 5-7
</code></pre></div></div>

<p>which implies all entries of the “class” type have to be between 1 and 3(inclusive) or 5 and 7. It’s always exactly two non-overlapping ranges and the second always starts after the first. So here is how I represented and parsed the rulesets:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">inclusive_range</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">rule</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">inclusive_range</span> <span class="n">lower</span><span class="p">,</span> <span class="n">higher</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">in</span><span class="p">,</span> <span class="n">rule</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">r</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">part</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">part</span> <span class="o">&amp;&amp;</span> <span class="n">part</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">!=</span><span class="sc">':'</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">r</span><span class="p">.</span><span class="n">name</span><span class="o">+=</span><span class="n">part</span><span class="o">+</span><span class="sc">' '</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">r</span><span class="p">.</span><span class="n">name</span><span class="o">+=</span><span class="n">part</span><span class="p">;</span>
	<span class="n">r</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
	
	<span class="kt">char</span> <span class="n">skip_c</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="p">.</span><span class="n">lower</span><span class="p">.</span><span class="n">start</span><span class="o">&gt;&gt;</span><span class="n">skip_c</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="p">.</span><span class="n">lower</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">part</span><span class="p">;</span>
	<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="p">.</span><span class="n">higher</span><span class="p">.</span><span class="n">start</span><span class="o">&gt;&gt;</span><span class="n">skip_c</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="p">.</span><span class="n">higher</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="n">in</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>With the parsing out of the way, as not exactly infrequently, the real task is just a form of counting:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">error_rate</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">tickets</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">tickets</span><span class="p">),</span><span class="mi">0</span><span class="p">,[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span> <span class="n">total</span><span class="p">,</span> <span class="k">const</span> <span class="k">auto</span> <span class="n">t</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">e</span><span class="o">:</span><span class="n">t</span><span class="p">.</span><span class="n">entries</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">bool</span> <span class="n">valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">r</span><span class="o">:</span><span class="n">rules</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="o">&gt;=</span><span class="n">r</span><span class="p">.</span><span class="n">lower</span><span class="p">.</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">.</span><span class="n">lower</span><span class="p">.</span><span class="n">end</span><span class="p">)</span>
					<span class="n">valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					
				<span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="o">&gt;=</span><span class="n">r</span><span class="p">.</span><span class="n">higher</span><span class="p">.</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">.</span><span class="n">higher</span><span class="p">.</span><span class="n">end</span><span class="p">)</span>
					<span class="n">valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">)</span>
				<span class="n">sum</span><span class="o">+=</span><span class="n">e</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="k">return</span> <span class="n">total</span> <span class="o">+</span> <span class="n">sum</span><span class="p">;</span>
	<span class="p">});</span></code></pre>
</figure>

<h3 id="part-2-15">Part 2</h3>

<p>Alright, now we get to the ever so slightly more interesting part: Identifying which column belongs to which field. The simplest way to do this is checking all options. The somewhat more clever one I could think of is to determine the first rule by finding one that can only be valid for one column. Afterwards, rinse and repeat:</p>

<p>First, we setup variables to keep track of which rules and fields we have already identified:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;&gt;</span> <span class="n">found_target_entry</span><span class="p">;</span>
<span class="n">found_target_entry</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">rules</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> 

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;&gt;</span> <span class="n">found_target_rule</span><span class="p">;</span>
<span class="n">found_target_rule</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">rules</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> 

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">rules_found_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre>
</figure>

<p>Determining if one and only one previously unassigned entry fits a given rule is done via this lovely lambda:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">determine_unique_entry_for</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">rule_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">entry_n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">tickets</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">entries</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">found_target_rule</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
				
		<span class="k">const</span> <span class="k">auto</span> <span class="n">valid</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">tickets</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">tickets</span><span class="p">),[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">is_valid</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">rules</span><span class="p">[</span><span class="n">rule_id</span><span class="p">]);</span>
		<span class="p">});</span>
				
		<span class="k">if</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">entry_n</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">entry_n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="n">entry_n</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">entry_n</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>It checks all, skipping over all assigned ones and checks validity. If no option or more than one valid option is found, we return nullopt, otherwise we return the index.</p>

<p>We then repeat it for all rules until everything becomes clear:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">while</span><span class="p">(</span><span class="n">rules_found_count</span><span class="o">&lt;</span><span class="n">rules</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">rules</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">found_target_entry</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="k">auto</span> <span class="n">entry_n</span> <span class="o">=</span> <span class="n">determine_unique_entry_for</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="n">entry_n</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">found_target_entry</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">entry_n</span><span class="p">;</span>
				<span class="n">found_target_rule</span><span class="p">[</span><span class="o">*</span><span class="n">entry_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="o">++</span><span class="n">rules_found_count</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>And that’s it for the day. It would - of course - fail spectacularly if more than one valid solution exited ;-)</p>

<p>Whilst I am not generally too big a fan of the validation type puzzles - as they really mostly test if you are capable of correctly reading instructions and data - the second part today was amazing and a lot of fun!</p>

<h2 id="day-17"><a href="https://github.com/philipplenk/adventofcode20/tree/main/17">Day 17</a></h2>

<h3 id="part-1-16">Part 1</h3>

<p>We already had one <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a> type puzzle this year, so seeing this one did not excite me too much at first. But in this tragic year it seemed needed and - reiterating the idea of <a href="https://en.wikipedia.org/wiki/Spiral_approach">spiraling</a> - this one did take the previous one up to 11. Or rather 3 and eventually 4.</p>

<p>We start of with an infinite 3 dimensional “Conway Cube” with only one slight slice initialized and are supposed to extrapolate its growth.</p>

<p>For this first task, I chose the probably worst possible representation of an expanding, very sparsely packed three dimensional grid possible: a vector of vector of string.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">layer</span><span class="o">&gt;</span> <span class="n">grid3d</span><span class="p">;</span></code></pre>
</figure>

<p>Doing it like this made the update step incredibly unwieldy and tedious, as I had to take care to add two layers and resize every layer by 2, whilst keeping track of shifted indices and different bounds for the updated copy:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">update_grid</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">layer</span><span class="o">&gt;</span> <span class="n">ret_val</span><span class="p">;</span>
	
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">z</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span><span class="n">z</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grid3d</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="o">++</span><span class="n">z</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ret_val</span><span class="p">.</span><span class="n">push_back</span><span class="p">({});</span>
		<span class="n">ret_val</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">resize</span><span class="p">(</span><span class="n">grid_height</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">row</span><span class="o">:</span> <span class="n">ret_val</span><span class="p">.</span><span class="n">back</span><span class="p">())</span>
			<span class="n">row</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">grid_width</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
		
		<span class="n">foreach_in_square</span><span class="p">({</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},{</span><span class="n">grid_width</span><span class="p">,</span><span class="n">grid_height</span><span class="p">},[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">p2</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">auto</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">point3d</span><span class="p">{</span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">};</span>
			
			<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">v</span><span class="o">:</span> <span class="n">directions</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="k">auto</span> <span class="n">target</span> <span class="o">=</span> <span class="n">p3</span><span class="o">+</span><span class="n">v</span><span class="p">;</span> <span class="n">valid_in_original</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>					
					<span class="n">count</span> <span class="o">+=</span> <span class="n">grid3d</span><span class="p">[</span><span class="n">target</span><span class="p">.</span><span class="n">z</span><span class="p">][</span><span class="n">target</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">target</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="sc">'#'</span><span class="p">;</span>
			<span class="p">}</span>
			 
			<span class="k">if</span><span class="p">(</span><span class="n">valid_in_original</span><span class="p">(</span><span class="n">p3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">grid3d</span><span class="p">[</span><span class="n">p3</span><span class="p">.</span><span class="n">z</span><span class="p">][</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="sc">'#'</span><span class="p">)</span>
				<span class="n">ret_val</span><span class="p">.</span><span class="n">back</span><span class="p">()[</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span><span class="o">==</span><span class="mi">2</span> <span class="o">||</span> <span class="n">count</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span><span class="o">?</span><span class="sc">'#'</span><span class="o">:</span><span class="sc">'.'</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ret_val</span><span class="p">.</span><span class="n">back</span><span class="p">()[</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span><span class="o">?</span><span class="sc">'#'</span><span class="o">:</span><span class="sc">'.'</span><span class="p">;</span>
		<span class="p">});</span>
	<span class="p">}</span>
	
	<span class="n">grid_width</span><span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">grid_height</span><span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>Certainly not the best code I have ever written, if you care for your eyes you should avert them.</p>

<h3 id="part-2-16">Part 2</h3>

<p>You thought 3 dimensions was fun? Let’s add another one and consider 4D hypercubes. My first surprisingly working solution simply extended the approach above logically. Instead of a vector of vector of string, I kept a vector of vector of vector of string and proceeded similarly to above, just one more nesting deeper. Quite the abomination, too horrendous to ever share with any living thing. I did, however, eventually see the error of my ways and recognized the problem description clearly screams for generalization of n dimensions, so generalize is what I did.</p>

<p>First of all, I needed arbitrarily dimensional vector and point structs</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">dim</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">vec</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">dim</span><span class="o">&gt;</span> <span class="n">coordinate</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">dim</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">point</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">dim</span><span class="o">&gt;</span> <span class="n">coordinate</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>with appropriate operator overloads like this:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">dim</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n">point</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">point</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">dim</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">lhs</span><span class="p">.</span><span class="n">coordinate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">rhs</span><span class="p">.</span><span class="n">coordinate</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	
	<span class="k">return</span> <span class="n">lhs</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Computing vectors to all neighbors can be done with some simple recursion:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">dim</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">neighbor_vectors</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;</span><span class="p">,</span><span class="n">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dim</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">ret_val</span><span class="p">;</span>
	
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="k">const</span> <span class="k">auto</span> <span class="n">recursive_fill</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;</span> <span class="n">current</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">coord</span><span class="p">,</span> <span class="k">auto</span> <span class="n">recurse</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">coord</span><span class="o">==</span><span class="n">dim</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">coordinate</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">coordinate</span><span class="p">),[](</span><span class="k">auto</span> <span class="n">v</span><span class="p">){</span> <span class="k">return</span> <span class="n">v</span><span class="o">==</span><span class="mi">0</span><span class="p">;</span> <span class="p">}))</span>
				<span class="n">ret_val</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">current</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="o">++</span><span class="n">v</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">current</span><span class="p">.</span><span class="n">coordinate</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">;</span>
			<span class="n">recurse</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">coord</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">recurse</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">};</span>
	
	<span class="n">recursive_fill</span><span class="p">({},</span><span class="mi">0</span><span class="p">,</span><span class="n">recursive_fill</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Given all that, I needed a better, less wasteful representation of the grid/cube/hypercube/whatever, i.e. of infinite space in arbitrary dimensions. The one I chose was a simple set of active/occupied cells:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">point</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;&gt;</span> <span class="n">cells</span><span class="p">;</span></code></pre>
</figure>

<p>An unordered_set, i.e. a hashset, might have been more efficient than this tree based one, but I really did not know how to define a good hash function for an arbitrarily large collection of integers, whilst a operator&lt; is very natural.</p>

<p>The update function becomes much better than in part 1, even bearable to look at:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">update_cells</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">point</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">counts</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span><span class="o">:</span> <span class="n">cells</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">n</span><span class="o">:</span> <span class="n">neighbor_vectors</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;</span><span class="p">())</span>
			<span class="o">++</span><span class="n">counts</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="p">];</span>
	
	<span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">point</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;&gt;</span> <span class="n">new_cells</span><span class="p">;</span>
	
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">count</span><span class="p">]</span><span class="o">:</span> <span class="n">counts</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">count</span><span class="o">==</span><span class="mi">3</span> <span class="o">||</span> <span class="p">(</span><span class="n">count</span><span class="o">==</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">cells</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">!=</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">cells</span><span class="p">)))</span>
			<span class="n">new_cells</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">new_cells</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>I first iterate over all active/set cells and add one to the neighbor count of each of their neighbors. I then iterate over those counts to create the new active cells according to the rules given. Almost beautiful ;-)</p>

<h2 id="day-18"><a href="https://github.com/philipplenk/adventofcode20/tree/main/18">Day 18</a></h2>

<h3 id="part-1-17">Part 1</h3>

<p>Expression parsing and evaluation! Great thing I have written some very simple toy (and still simple, but not so toy) compilers before :). First thing is simply evaluating with no precedence at all, just considering parenthesis and left to right, which can easily be done in one pass.</p>

<p>First, we define how to parse a single operation:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">operation</span> <span class="nf">parse_operation</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">expression</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">expression</span><span class="o">&gt;&gt;</span><span class="n">std</span><span class="o">::</span><span class="n">ws</span><span class="p">;</span>
	
	<span class="n">operation</span> <span class="n">op</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">expression</span><span class="p">.</span><span class="n">peek</span><span class="p">()</span><span class="o">==</span><span class="sc">'*'</span><span class="p">)</span>
		<span class="n">op</span><span class="o">=</span><span class="n">operation</span><span class="o">::</span><span class="n">multiply</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">op</span><span class="o">=</span><span class="n">operation</span><span class="o">::</span><span class="n">add</span><span class="p">;</span>

	<span class="n">expression</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
		
	<span class="k">return</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Skip all whitespace and return operation::add or operation::multiply depending on the character seen(We should only support addition and multiplication). Nothing fancy so far. Parsing an operand, however, already contains most of the logic:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="kt">long</span> <span class="nf">parse_operand</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">expression</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">expression</span><span class="o">&gt;&gt;</span><span class="n">std</span><span class="o">::</span><span class="n">ws</span><span class="p">;</span>
	
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">expression</span><span class="p">.</span><span class="n">peek</span><span class="p">()</span><span class="o">==</span><span class="sc">'('</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">expression</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">expression</span><span class="o">&gt;&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>	</code></pre>
</figure>

<p>If the operand is a simple number, we read and return it. Otherwise, we first recursively evaluate the subexpression describing it and then return its result. Evaluation itself can now be described in terms of the two functions above:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="kt">long</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">expression</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">parse_operand</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
	
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">operation</span> <span class="n">op</span> <span class="o">=</span> <span class="n">parse_operation</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
		
		<span class="kt">long</span> <span class="kt">long</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">parse_operand</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
			
		<span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="o">==</span><span class="n">operation</span><span class="o">::</span><span class="n">add</span><span class="o">?</span><span class="p">(</span><span class="n">result</span><span class="o">+</span><span class="n">rhs</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">result</span><span class="o">*</span><span class="n">rhs</span><span class="p">);</span>

		<span class="n">expression</span><span class="o">&gt;&gt;</span><span class="n">std</span><span class="o">::</span><span class="n">ws</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">expression</span><span class="p">.</span><span class="n">peek</span><span class="p">()</span><span class="o">==</span><span class="sc">')'</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">expression</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">while</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>We first parse the left operand, followed by the operation and its right operand. Our result gets computed as the result of applying the operator to it and the right operand. While there are still more operations to process, we repeat the procedure with result as the new left operand.</p>

<p>Not the most pretty, not the most ugly, just simple enough and it gave the correct result on first try and me place 185th on the damn global leaderboard. So close, yet so far…</p>

<h3 id="part-2-17">Part 2</h3>

<p>Now we do have a precedence, just the opposite of what is commonly used. In hindsight, it might have been worth it to just swap the symbols, let some automatic parenthesizing program run over it, swap them again and use bc or something like it. Or copy the expressions to code and use custom types with overloaded operators. I believe many solutions worked exactly like that, taking advantage of already properly implemented precedence rules in languages and calculators. I, as I tend to do in life, went the long and tedious route:</p>

<p>It wasn’t really that long and tedious so. All that had to be adjusted was the evaluate function and the change was rather minimal and intuitive. Ignore subexpressions for a moment - as those are handled recursively by parse_operand anyway - and simply consider what is happening here:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1+2*3+4+5*6+7*9+8+7
</code></pre></div></div>

<p>That is interpreted as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1+2)*(3+4+5)*(6+7)*(9+8+7)
</code></pre></div></div>

<p>As you can see, we have a product of sums. What we can do, as such, is keep a running product, starting with 1 and a running sum, starting with the first operand. We then add to the sum until we encounter a multiply, at which point we multiply our running product by the sum and reset sum to zero.</p>

<p>With our example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>product = 1, sum = 1;
sum = 3
product = 1*3, sum = 0
sum = 3
sum = 7
sum = 12
product = 3*12, sum = 0
</code></pre></div></div>

<p>and so on. At the very end, we return the running product multiplied by the last sum. Here it is in code:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="kt">long</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">expression</span><span class="p">)</span>
<span class="p">{</span>	
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">parse_operand</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
	
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">product</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="n">operation</span> <span class="n">op</span> <span class="o">=</span> <span class="n">parse_operation</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
		
		<span class="kt">long</span> <span class="kt">long</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">parse_operand</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
			
		<span class="k">if</span><span class="p">(</span><span class="n">op</span><span class="o">==</span><span class="n">operation</span><span class="o">::</span><span class="n">multiply</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">product</span><span class="o">*=</span><span class="n">lhs</span><span class="p">;</span>
			<span class="n">lhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">lhs</span><span class="o">+=</span><span class="n">rhs</span><span class="p">;</span>
			
		<span class="n">expression</span><span class="o">&gt;&gt;</span><span class="n">std</span><span class="o">::</span><span class="n">ws</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">expression</span><span class="p">.</span><span class="n">peek</span><span class="p">()</span><span class="o">==</span><span class="sc">')'</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">expression</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">while</span><span class="p">(</span><span class="n">expression</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">product</span><span class="o">*</span><span class="n">lhs</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<h2 id="day-19"><a href="https://github.com/philipplenk/adventofcode20/tree/main/19">Day 19</a></h2>

<h3 id="part-1-18">Part 1</h3>

<p>More parsing fun, but this time the difficulty is not so much in parsing but in writing a proper parser. We are given a bunch of simple replacement rules and are supposed to tell how many of the input strings match the rules. At first, they are non-recursive and provided in a simple form:</p>

<p>0: 1 2
1: “a”
2: 1 3 | 3 1
3: “b”</p>

<p>This is basically a very simple <a href="https://en.wikipedia.org/wiki/Formal_grammar">grammar</a>, with numbers as nonterminals and characters as terminals. I chose to represent the production rules as a simple struct:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">enum</span> <span class="k">class</span> <span class="nc">type</span>
<span class="p">{</span>
	<span class="n">terminal</span><span class="p">,</span>
	<span class="n">nonterminal</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">rule</span>
<span class="p">{</span>
	<span class="n">type</span> <span class="n">t</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;&gt;</span> <span class="n">sequences</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>If type is terminal, the char matters, otherwise the vector of alternative sequences is relevant. Given that exclusivity, I would have done better to use a <a href="https://en.cppreference.com/w/cpp/utility/variant">std::variant</a> instead, but I guess I was feeling particularly lazy that day.</p>

<p>The parser itself is, as so frequently, a simple recursive function with this signature:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">str</span><span class="p">,</span> <span class="kt">long</span> <span class="n">rule_id</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">follow</span><span class="p">,</span> <span class="k">auto</span> <span class="n">recurse</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span></code></pre>
</figure>

<p>“str” is what remains of the input, “rule_id” identifies the first rule we are trying to match, whilst “follow” is a list of rules we have to match after that first one.</p>

<p>Matching differentiates based on the next rule type. If it is a terminal, i.e. a single character, we simply compare the next input character:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">r</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">str</span><span class="p">.</span><span class="n">remove_prefix</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">follow</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">str</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
			
	<span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">follow</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
	<span class="n">follow</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">recurse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="n">next</span><span class="p">,</span><span class="n">follow</span><span class="p">,</span><span class="n">recurse</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span></code></pre>
</figure>

<p>If it does not match, we failed. If it succeeded and we have no more rules to match, we succeed exactly if we consumed all of our input. Otherwise, we recursively try to match the next rule in our sequence.</p>

<p>If, on the contrary, we are dealing with a nonterminal, matching is a little more complicated, as we have to try all options:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">seq</span><span class="o">:</span> <span class="n">r</span><span class="p">.</span><span class="n">sequences</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">follow_cpy</span> <span class="o">=</span> <span class="n">follow</span><span class="p">;</span>
	<span class="n">follow_cpy</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">follow_cpy</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">seq</span><span class="p">));</span>
	<span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">follow_cpy</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
	<span class="n">follow_cpy</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
	<span class="k">if</span><span class="p">(</span><span class="n">recurse</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="n">next</span><span class="p">,</span><span class="n">follow_cpy</span><span class="p">,</span><span class="n">recurse</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
	
<span class="k">return</span> <span class="nb">false</span><span class="p">;</span></code></pre>
</figure>

<p>For each of our possible sequences, we first create a copy of what has to follow so far and prepend that with the sequence we are currently testing. Then we proceed as we did in the terminal case above, by taking off the first of that sequence and recursing. If any one of the recursive calls succeeded, we propagate success. Otherwise, we propagate failure.</p>

<h3 id="part-2-18">Part 2</h3>

<p>For part 2, we were supposed to replace two rules, thereby introducing right recursion. We were warned - in not too weak terms - that we should only try to handle our special case and a general solution would be significantly more difficult. I was stumped for several minutes trying to figure out what such a special cased solution would look like, until I decided to try and see what my solution would do with the modified input. Turns out it seems to have been perfectly general already and spewed out the correct answer within the fraction of a second. Wasted minutes and leaderboard opportunities… Oh well, next year is another chance xD</p>

<h2 id="day-20"><a href="https://github.com/philipplenk/adventofcode20/tree/main/20">Day 20</a></h2>

<h3 id="part-1-19">Part 1</h3>

<p>This one was quite interesting. A puzzle that was literally… a puzzle ;-). Given a bunch of “tiles”, i.e. small rectangles of either “.” or “#”, the task was to reassemble a complete image by placing, rotating and flipping the tiles such that all borders match up. Part 1, however, was a significantly easier first step to this grand endeavor: Determining which tiles are corner tiles. A tiny bit of thought reveals that all tiles appearing on the inside match at least 3 other tiles on at least 3 of their borders. As such, we first need to determine the 4 borders:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">get_borders</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">grid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">borders</span><span class="p">;</span>
	<span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">grid</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
	<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">line</span><span class="o">:</span> <span class="n">grid</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">borders</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">borders</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">borders</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>“grid” here is a vector of string, the unfortunately inefficient representation I chose at the time. For this part, it was entirely unnecessary to save more than the borders and those could have been a simple bitset/integer instead. Nonetheless, due to an irresistible bout of laziness and in anticipation of what was to come, for better or worse, I did as I did.</p>

<p>Given a way to get at the borders for any given tile, we need a way to check if any borders of two tiles could match, regardless of orientation:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">match_sides</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">grid_lhs</span><span class="p">,</span> <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">grid_rhs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">lhs_borders</span> <span class="o">=</span> <span class="n">get_borders</span><span class="p">(</span><span class="n">grid_lhs</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">rhs_borders</span> <span class="o">=</span> <span class="n">get_borders</span><span class="p">(</span><span class="n">grid_rhs</span><span class="p">);</span>
	
	<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="o">:</span> <span class="n">lhs_borders</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="o">:</span> <span class="n">rhs_borders</span><span class="p">)</span>
			<span class="k">if</span><span class="p">(</span><span class="n">lhs</span><span class="o">==</span><span class="n">rhs</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
				
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="o">:</span> <span class="n">rhs_borders</span><span class="p">)</span>
		<span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">rhs</span><span class="p">));</span>
	
	<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="o">:</span> <span class="n">lhs_borders</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="o">:</span> <span class="n">rhs_borders</span><span class="p">)</span>
			<span class="k">if</span><span class="p">(</span><span class="n">lhs</span><span class="o">==</span><span class="n">rhs</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
				
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>We then can, in horrendously quadratic brute force fashion, determine all possible neighbors for all tiles:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">tiles</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">other_it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="n">other_it</span><span class="o">!=</span><span class="n">tiles</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">other_it</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">match_sides</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span><span class="n">other_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">neighbors</span><span class="p">[</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">other_it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
			<span class="n">neighbors</span><span class="p">[</span><span class="n">other_it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>The looked for tiles are those with exactly 2 possible neighbors and we were supposed to return the product of their ids:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="n">product</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">id</span><span class="p">,</span><span class="n">neighbors</span><span class="p">]</span><span class="o">:</span> <span class="n">neighbors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">neighbors</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
		<span class="n">product</span><span class="o">*=</span><span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">product</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span></code></pre>
</figure>

<p>All of this could, of course, have failed miserably, as there is no real reason why a corner tile could not match any additional tiles on at least one side, but it seems like we were supposed to get lucky.</p>

<h3 id="part-2-19">Part 2</h3>

<p>Alright, now that we have the corners, solving the complete puzzle and reassembling our image should be trivial, right? Well, it should be…</p>

<p>I did, however, run into some troubles along the way, wrapping my head around it was the cause of some minor and major headaches and I spent far more time than I’d be willing to admit until I got all the details just right. My code is a bit of mess, so before we get to it, allow me to explain in general terms what I eventually came up with:</p>

<p>Assume we start out with an empty grid</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>....
....
....
....
</code></pre></div></div>

<p>Begin by setting any arbitrary corner tile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0...
....
....
....
</code></pre></div></div>

<p>As corner has exactly 2 neighbors and we do not care if our assembled image is in the “correct” orientation - whatever that even means - we can randomly assign one of them to the right and the other to the bottom:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>01..
2...
....
....
</code></pre></div></div>

<p>What now? Consider the position marked “X”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>01..
2X..
....
....
</code></pre></div></div>

<p>What do we know about the tile which will eventually end up there? It has 4 neighbors, two of which will be 1 and 2. It is also the only tile adjacent to both of them! Two placed neighbors are always enough to uniquely identify any tiles position. As such, we can place all tiles with that property:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>01..
23..
....
....
</code></pre></div></div>

<p>Aaaand, we are stuck again. Or are we? 1 and 2 have exactly one unplaced neighbor left and exactly one space to put it. As such, we can place those, leaving us with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>014.
23..
5...
....
</code></pre></div></div>

<p>Which provides us with two more positions clearly defined by two neighbors. Filling them gives us two more tiles on the edges. Rinse and repeat until the grid is filled.</p>

<p>Which brings us to the god awful implementation. We first do exactly what we did in part 1, just instead of outputting some value based on the corner ids, we select one of them as the starting point for whatever we will do next:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">id</span><span class="p">,</span><span class="n">neighbors</span><span class="p">]</span><span class="o">:</span> <span class="n">neighbors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">neighbors</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>For simplicities sake, I once again inefficiently represented a grid as map and used a hashmap to keep track of which tiles were already set:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">used</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">point2d</span><span class="p">,</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">grid</span><span class="p">;</span></code></pre>
</figure>

<p>Filling the grid is done as described above:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">point2d</span> <span class="n">p</span><span class="p">,</span> <span class="kt">long</span> <span class="n">id</span><span class="p">,</span> <span class="kt">long</span> <span class="n">right_id</span><span class="p">,</span> <span class="kt">long</span> <span class="n">down_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">used</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">used</span><span class="p">[</span><span class="n">right_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">used</span><span class="p">[</span><span class="n">down_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	
	<span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">vec2d</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">}]</span> <span class="o">=</span> <span class="n">right_id</span><span class="p">;</span>
	<span class="n">grid</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">vec2d</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}]</span> <span class="o">=</span> <span class="n">down_id</span><span class="p">;</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">neighbors</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">id</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span><span class="o">:</span> <span class="n">neighbors</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">defined_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">n_id</span><span class="o">:</span> <span class="n">n</span><span class="p">)</span>
				<span class="n">defined_count</span> <span class="o">+=</span> <span class="n">used</span><span class="p">[</span><span class="n">n_id</span><span class="p">]</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
				
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">defined_count</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">)</span>
				<span class="n">place_tile</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
			
		<span class="p">}</span>
		
		<span class="n">right_id</span> <span class="o">=</span> <span class="n">place_missing_at</span><span class="p">(</span><span class="n">right_id</span><span class="p">,</span><span class="n">vec2d</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span>
		<span class="n">down_id</span> <span class="o">=</span> <span class="n">place_missing_at</span><span class="p">(</span><span class="n">down_id</span><span class="p">,</span><span class="n">vec2d</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>
	<span class="p">}</span>
<span class="p">};</span></code></pre>
</figure>

<p>First, we set the three initial tiles and then, until we have set all of them, we fill in those with two neighbors, advance the ones on the borders and repeat.</p>

<p>To find where to place one with two neighbors, we find the position of those neighbors and take the max of their x and y coordinates:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">place_tile</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">long</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">point2d</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">n_coord</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">n_id</span><span class="p">]</span><span class="o">:</span> <span class="n">grid</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">n</span><span class="o">:</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">id</span><span class="p">])</span>
			<span class="k">if</span><span class="p">(</span><span class="n">n_id</span><span class="o">==</span><span class="n">n</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">n_coord</span><span class="p">[</span><span class="n">found</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">const</span> <span class="n">point2d</span> <span class="n">place_at</span> <span class="o">=</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">n_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span><span class="p">,</span><span class="n">n_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">n_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span><span class="p">,</span><span class="n">n_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">)};</span>
	<span class="n">used</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">grid</span><span class="p">[</span><span class="n">place_at</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>The direction for the other case is predefined, so we only need to find the unset neighbor and add the direction vector:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">place_missing_at</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">long</span> <span class="n">set_neighbor_id</span><span class="p">,</span> <span class="n">vec2d</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">point2d</span> <span class="n">n_coord</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">n_id</span><span class="p">]</span><span class="o">:</span> <span class="n">grid</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">n_id</span> <span class="o">==</span> <span class="n">set_neighbor_id</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">n_coord</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">n_id</span><span class="o">:</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">set_neighbor_id</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">n_id</span><span class="p">])</span>
		<span class="p">{</span>			
			<span class="n">used</span><span class="p">[</span><span class="n">n_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">n_coord</span><span class="o">+</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_id</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">set_neighbor_id</span><span class="p">;</span>
	
<span class="p">};</span></code></pre>
</figure>

<p>Afterwards, we still have to correct flips and rotations, remove the border, compose a complete grid and search for a specified pattern - an ascii art sea monster - within that image. As that is not particularly interesting, quite tedious and even repetitive, I refer you to <a href="https://github.com/philipplenk/adventofcode20/tree/main/20/02.cpp">the complete code</a> instead of elaborating on it any further. It is a mess and you have been warned ;-)</p>

<h2 id="day-21"><a href="https://github.com/philipplenk/adventofcode20/tree/main/21">Day 21</a></h2>

<h3 id="part-1-20">Part 1</h3>

<p>Given a list of unknown ingredients and a list of allergens contained in them (each allergen appearing in exactly one ingredient, each ingredient containing at most one allergen and not all allergens listed every time), we are tasked with figuring out which ingredient contains which allergen. Well, first of all we are asked a simpler question: which ingredients do definitely not contain any allergen.
It took me a while to understand what exactly was asked here, but it all comes down to set intersections and differences. Whenever an allergen is contained in two lists, it must be contained in the intersection of those lists, not in the difference. Thanks to the beauty of the C++ standard library, this simple insight leads to a very straightforward solution using simple calls to std::set_intersection and std::set_difference:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">d</span><span class="o">:</span> <span class="n">dishes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">a</span><span class="o">:</span> <span class="n">d</span><span class="p">.</span><span class="n">allergens</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">auto</span><span class="o">&amp;</span> <span class="n">old</span> <span class="o">=</span> <span class="n">allergen_to_ingredient</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">corrected</span><span class="p">;</span>
		
				<span class="n">std</span><span class="o">::</span><span class="n">set_intersection</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">old</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">old</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">ingredients</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">ingredients</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">corrected</span><span class="p">));</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">corrected</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
	
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">harmless</span> <span class="o">=</span> <span class="n">all_ingredients</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">ing</span><span class="p">]</span> <span class="o">:</span><span class="n">allergen_to_ingredient</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">corrected</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">set_difference</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">harmless</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">harmless</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">ing</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">ing</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">corrected</span><span class="p">));</span>
	<span class="n">harmless</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">corrected</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</figure>

<h3 id="part-2-20">Part 2</h3>

<p>Having solved this simple question, we now have to uniquely identify which ingredient contains which allergen. Given our previous solution and knowing it is uniquely solvable, this is rather trivial. First, identify one allergen that can only be in one ingredient. Remove it as a possibility from all other allergens. Rinse and repeat:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">done_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">do</span>
<span class="p">{</span>
	<span class="n">done_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">ing</span><span class="p">]</span> <span class="o">:</span><span class="n">allergen_to_ingredient</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ing</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="o">++</span><span class="n">done_cnt</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">a_other</span><span class="p">,</span><span class="n">ing_other</span><span class="p">]</span> <span class="o">:</span><span class="n">allergen_to_ingredient</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">a_other</span><span class="o">==</span><span class="n">a</span> <span class="o">||</span> <span class="n">ing_other</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
				<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">corrected</span><span class="p">;</span>
				<span class="n">std</span><span class="o">::</span><span class="n">set_difference</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">ing_other</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">ing_other</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">ing</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">ing</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">corrected</span><span class="p">));</span>
				<span class="n">ing_other</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">corrected</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">while</span><span class="p">(</span><span class="n">done_cnt</span><span class="o">&lt;</span><span class="n">allergen_to_ingredient</span><span class="p">.</span><span class="n">size</span><span class="p">());</span></code></pre>
</figure>

<h2 id="day-22"><a href="https://github.com/philipplenk/adventofcode20/tree/main/22">Day 22</a></h2>

<h3 id="part-1-21">Part 1</h3>

<p>Space Cards! Almost missed them from last year, when they proved <a href="https://adventofcode.com/2019/day/22">one of the most interesting challenges</a>, due to their sheer number alone. This year, however, we are far more relaxed. Hardly any shuffling involved, just a <a href="https://en.wikipedia.org/wiki/War_(card_game)">simple game between two players</a>.</p>

<p>Both are given a deck of numbered cards and repeatedly and simultaneously draw and reveal their top card. The owner of the higher valued one wins the lower one and puts both cards below their own deck. Once a deck is cleared, the other player is declared the winner. Rather straightforward so far:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">player0</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">player1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">player0</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">&gt;</span><span class="n">player1</span><span class="p">.</span><span class="n">back</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">auto</span> <span class="n">other</span> <span class="o">=</span> <span class="n">player1</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">player0</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">player0</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
		<span class="n">player0</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="n">player0</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="n">player1</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">auto</span> <span class="n">other</span> <span class="o">=</span> <span class="n">player0</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">player1</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">player1</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
		<span class="n">player1</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="n">player0</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="n">player1</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>If we only wanted to know who wins, it would be enough to check who owns the highest card in the beginning. The required result, however, was a score computed based on the order in the final deck and I couldn’t think of any better solution than a simple simulation.</p>

<h3 id="part-2-21">Part 2</h3>

<p>Part 2, as usual, is where things get interesting. Whenever the two top numbers are smaller than what is left of the respective decks, we recurse on a copy of the top that many cards to determine the winner. If a position repeats, player 0 wins by default.</p>

<p>That rule was a bit ambiguous and hard to grasp. What player 0 wins is that single subgame. Not the current round and not the whole game. I lost about 10 minutes on misunderstanding that, as I thought it referred to the round only and got an error I failed to understand. The given example input does not trigger that specific case and erroneous behavior, yielding the correct result even with the misunderstanding. Well, the rest was fairly easy with the difficulty coming mainly from more or less efficiently implementing the game rules, which I notably did not do.</p>

<p>I am certain it could be optimized significantly, as my solution takes about half a second on my laptop, which is huge. I am, however, lazy, so I declared it adequate.</p>

<p>The main game logic is pretty much equivalent to the one from part 1. I just cleaned it up a little bit and used a call to a more complicated function to determine who wins the next card instead of simply comparing the top ones:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">decks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">decks</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span> <span class="n">cache_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">compute_id</span><span class="p">(</span><span class="n">decks</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">compute_id</span><span class="p">(</span><span class="n">decks</span><span class="p">[</span><span class="mi">1</span><span class="p">])};</span>
	<span class="k">if</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">cache_id</span><span class="p">)</span><span class="o">!=</span><span class="n">cache</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">ret_val_t</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="n">compute_score</span><span class="p">(</span><span class="n">decks</span><span class="p">[</span><span class="mi">0</span><span class="p">])};</span>
	
	<span class="n">cache</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cache_id</span><span class="p">);</span>
			
	<span class="k">const</span> <span class="k">auto</span> <span class="n">winner</span> <span class="o">=</span> <span class="n">next_card_winner</span><span class="p">();</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">loser</span> <span class="o">=</span> <span class="n">winner</span><span class="o">==</span><span class="mi">0</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
	
	<span class="k">const</span> <span class="k">auto</span> <span class="n">other</span> <span class="o">=</span> <span class="n">decks</span><span class="p">[</span><span class="n">loser</span><span class="p">].</span><span class="n">back</span><span class="p">();</span>
	<span class="n">decks</span><span class="p">[</span><span class="n">winner</span><span class="p">].</span><span class="n">push_front</span><span class="p">(</span><span class="n">decks</span><span class="p">[</span><span class="n">winner</span><span class="p">].</span><span class="n">back</span><span class="p">());</span>
	<span class="n">decks</span><span class="p">[</span><span class="n">winner</span><span class="p">].</span><span class="n">push_front</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="n">decks</span><span class="p">[</span><span class="n">winner</span><span class="p">].</span><span class="n">pop_back</span><span class="p">();</span>
	<span class="n">decks</span><span class="p">[</span><span class="n">loser</span><span class="p">].</span><span class="n">pop_back</span><span class="p">();</span>			
<span class="p">}</span></code></pre>
</figure>

<p>I also kept a set of already appeared deck combinations, to implement the “player 1 wins on repetition” rule. <em>next_card_winner</em> is equally trivial:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">next_card_winner</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
<span class="p">{</span>		
	<span class="k">if</span><span class="p">(</span><span class="n">decks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">back</span><span class="p">()</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">decks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">decks</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">back</span><span class="p">()</span><span class="o">&lt;</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">decks</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">()))</span>
	<span class="p">{</span>
		<span class="k">auto</span> <span class="n">decks_new</span> <span class="o">=</span> <span class="n">decks</span><span class="p">;</span>
		<span class="n">decks_new</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="n">decks_new</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">pop_back</span><span class="p">();</span>
		
		<span class="n">decks_new</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">decks_new</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">decks_new</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">decks_new</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="n">decks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">back</span><span class="p">());</span>
		<span class="n">decks_new</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">decks_new</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">decks_new</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="n">decks_new</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="n">decks</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">back</span><span class="p">());</span>
				
		<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">decks_new</span><span class="p">),</span><span class="n">recurse</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="n">winner_id</span><span class="p">;</span>
	<span class="p">}</span>	
		
	<span class="k">return</span> <span class="n">decks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">back</span><span class="p">()</span><span class="o">&gt;</span><span class="n">decks</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">back</span><span class="p">()</span><span class="o">?</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>If there are enough cards in both decks, we recurse into a subgame and return the winner of that. Otherwise, the higher card wins.</p>

<h2 id="day-23"><a href="https://github.com/philipplenk/adventofcode20/tree/main/23">Day 23</a></h2>

<p>Well, that was an experience… My sleep deprivation at this point might have hit a new high, causing me to have somewhat less concentration and a much better excuse than usual, but it is just an excuse and I failed to see the obvious solution right in front of my eyes. But that’s something for later, first, lets describe the problem:</p>

<h3 id="part-1-22">Part 1</h3>

<p>Given a bunch of numbered cups, arranged in a circle, our opponent - a very intelligent crab, apparently the <a href="https://en.wikipedia.org/wiki/Carcinisation">pinnacle of evolution</a> - rearranges them according to a number of simple rules. We have to determine where a specific cup ends up after a given number of moves. In each move, the crab picks up three cups clockwise after the “current” one and moves them right after the next lower numbered cup. The one after the newly inserted ones then becomes the next “current” cup.</p>

<p>Here is my hacky, god-awful looking and performing code simulating one such move:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">move</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">current</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">original_value</span> <span class="o">=</span> <span class="n">cups</span><span class="p">[</span><span class="n">current</span><span class="p">];</span>
	<span class="k">auto</span> <span class="n">target_value</span> <span class="o">=</span> <span class="n">cups</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">target_value</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">target_value</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
	 
	<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">taken</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">taken</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cups</span><span class="p">[(</span><span class="n">current</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">cups</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
		<span class="n">cups</span><span class="p">[(</span><span class="n">current</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">cups</span><span class="p">.</span><span class="n">size</span><span class="p">()]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cups</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">cups</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">cups</span><span class="p">),</span><span class="mi">0</span><span class="p">),</span><span class="n">cups</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">taken</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">taken</span><span class="p">),</span><span class="n">target_value</span><span class="p">)</span><span class="o">!=</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">taken</span><span class="p">))</span>
		<span class="n">target_value</span> <span class="o">=</span> <span class="n">target_value</span><span class="o">==</span><span class="mi">1</span><span class="o">?</span><span class="mi">9</span><span class="o">:</span><span class="p">(</span><span class="n">target_value</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="k">auto</span> <span class="n">target_pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">cups</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">cups</span><span class="p">),</span><span class="n">target_value</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		
	<span class="n">cups</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">target_pos</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">taken</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">taken</span><span class="p">));</span>
	
	<span class="k">auto</span> <span class="n">original_pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">cups</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">cups</span><span class="p">),</span><span class="n">original_value</span><span class="p">)</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">cups</span><span class="p">);</span>
		
	<span class="k">if</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">current</span><span class="p">)</span><span class="o">&lt;</span><span class="n">original_pos</span><span class="p">)</span>
		<span class="n">std</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">cups</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">cups</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">original_pos</span><span class="o">-</span><span class="n">current</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">cups</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">std</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">rbegin</span><span class="p">(</span><span class="n">cups</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">rbegin</span><span class="p">(</span><span class="n">cups</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">current</span><span class="o">-</span><span class="n">original_pos</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">rend</span><span class="p">(</span><span class="n">cups</span><span class="p">));</span>
	
	<span class="k">return</span> <span class="p">(</span><span class="n">current</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">cups</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</figure>

<p>As you can see, I chose to represent the cups as integers in a giant array and copied and shifted them around, which was likely the worst, most expensive representation possible and which came back to bite me in part 2.</p>

<h3 id="part-2-22">Part 2</h3>

<p>Part 2 took the problem up to 11. Or rather up to 1000000 cups * 10000000 moves, causing this most trivial of brute force solutions to fail horrendously.</p>

<p>For the longest of times, I suspected there must be some sort of clever closed form solution. Turns out it was just an issue with implementing it in a little less brain dead way. A lot of cursing later, I realized that - of course - this is <strong>NOT</strong> a <a href="https://www.youtube.com/watch?v=UZmeDQL4LaE">rotate</a>, its simply a freaking linked list and that is one of the very few cases where using one actually proves more efficient and beneficial than a simple vector. Especially as we can still find any given list element in O(1), as they only contain one number. So <a href="https://github.com/philipplenk/adventofcode20/tree/main/23/02_unordered_map.cpp">this simple solution</a> finally gave me my desired star, using two hashmaps to represent the lists:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">cups</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">next</span><span class="p">[</span><span class="n">cups</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">cups</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">cups</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
	<span class="n">prev</span><span class="p">[</span><span class="n">cups</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">cups</span><span class="p">[</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="o">?</span><span class="p">(</span><span class="n">cups</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)];</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">auto</span> <span class="n">move</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">original_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">target_value</span> <span class="o">=</span> <span class="n">original_value</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">target_value</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">target_value</span> <span class="o">=</span> <span class="n">cups</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
	 
	<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">taken</span><span class="p">;</span>
	<span class="n">taken</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">original_value</span><span class="p">];</span>
	<span class="n">taken</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">taken</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
	<span class="n">taken</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">taken</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span>
	
	<span class="n">prev</span><span class="p">[</span><span class="n">next</span><span class="p">[</span><span class="n">taken</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">original_value</span><span class="p">;</span>
	<span class="n">next</span><span class="p">[</span><span class="n">original_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">taken</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">taken</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">taken</span><span class="p">),</span><span class="n">target_value</span><span class="p">)</span><span class="o">!=</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">taken</span><span class="p">))</span>
		<span class="n">target_value</span> <span class="o">=</span> <span class="n">target_value</span><span class="o">==</span><span class="mi">1</span><span class="o">?</span><span class="n">cups</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">:</span><span class="p">(</span><span class="n">target_value</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="n">next</span><span class="p">[</span><span class="n">taken</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">target_value</span><span class="p">];</span>
	<span class="n">next</span><span class="p">[</span><span class="n">target_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">taken</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">prev</span><span class="p">[</span><span class="n">taken</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">target_value</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="n">next</span><span class="p">[</span><span class="n">original_value</span><span class="p">];</span>
<span class="p">};</span></code></pre>
</figure>

<p>That is - of course - an utter waste and neither hashmaps nor doubly linked lists are required here. Instead, we can simply store the indices of our followup elements as a sort of in place forward list</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">forward_list_element</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">forward_list_element</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">;</span>
<span class="n">list</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span></code></pre>
</figure>

<p>and implement a move by changing the followup indices of the current element and the last one taken:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">move</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">original_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">target_value</span> <span class="o">=</span> <span class="n">original_value</span><span class="o">==</span><span class="mi">0</span><span class="o">?</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">original_value</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	 
	<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">taken</span><span class="p">;</span>
	<span class="n">taken</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">list</span><span class="p">[</span><span class="n">original_value</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
	<span class="n">taken</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">list</span><span class="p">[</span><span class="n">taken</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">next</span><span class="p">;</span>
	<span class="n">taken</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">list</span><span class="p">[</span><span class="n">taken</span><span class="p">[</span><span class="mi">1</span><span class="p">]].</span><span class="n">next</span><span class="p">;</span>
	
	<span class="n">list</span><span class="p">[</span><span class="n">original_value</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">taken</span><span class="p">[</span><span class="mi">2</span><span class="p">]].</span><span class="n">next</span><span class="p">;</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">taken</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">taken</span><span class="p">),</span><span class="n">target_value</span><span class="p">)</span><span class="o">!=</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">taken</span><span class="p">))</span>
		<span class="n">target_value</span> <span class="o">=</span> <span class="n">target_value</span><span class="o">==</span><span class="mi">0</span><span class="o">?</span><span class="n">list</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="p">(</span><span class="n">target_value</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="n">list</span><span class="p">[</span><span class="n">taken</span><span class="p">[</span><span class="mi">2</span><span class="p">]].</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">target_value</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
	<span class="n">list</span><span class="p">[</span><span class="n">target_value</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">taken</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	
	<span class="k">return</span> <span class="n">list</span><span class="p">[</span><span class="n">original_value</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<h2 id="day-24"><a href="https://github.com/philipplenk/adventofcode20/tree/main/24">Day 24</a></h2>

<h3 id="part-1-23">Part 1</h3>

<p>Flipping tiles in a hex grid. Fun, if only I remembered to get my stupid hex coordinates right. Took me a while to get back to it and in my learning I discovered <a href="https://www.redblobgames.com/grids/hexagons/">a beautiful resource going into great detail</a>, which I highly recommend reading.</p>

<p>Especially the little graphic under axial coordinates listing neighbors really saved my skin this time. Everything but this was, of course, rather trivial.</p>

<p>Starting out with an infinitely extending hexagonal grid, all of which white, we were given a number of pathes from a starting point and were supposed to flip the tiles on the destinations to black(or back to white if they were reached a second time).</p>

<p>As such, we need to represent binary colors and offer a way to flip them:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">enum</span> <span class="k">class</span> <span class="nc">color</span>
<span class="p">{</span>
	<span class="n">white</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">black</span>
<span class="p">};</span>

<span class="n">color</span> <span class="nf">flip</span><span class="p">(</span><span class="n">color</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">c</span><span class="o">==</span><span class="n">color</span><span class="o">::</span><span class="n">white</span><span class="o">?</span><span class="n">color</span><span class="o">::</span><span class="n">black</span><span class="o">:</span><span class="n">color</span><span class="o">::</span><span class="n">white</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>As well as the 6 possible hexadecimal directions and a way to compute coordinates based on them:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">enum</span> <span class="k">class</span> <span class="nc">hex_direction</span>
<span class="p">{</span>
	<span class="n">e</span><span class="p">,</span>
	<span class="n">w</span><span class="p">,</span>
	<span class="n">se</span><span class="p">,</span>
	<span class="n">sw</span><span class="p">,</span>
	<span class="n">ne</span><span class="p">,</span>
	<span class="n">nw</span>
<span class="p">};</span>

<span class="n">vec2d</span> <span class="nf">to_vec2d</span><span class="p">(</span><span class="n">hex_direction</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="n">hex_direction</span><span class="o">::</span><span class="n">e</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
		<span class="k">case</span> <span class="n">hex_direction</span><span class="o">::</span><span class="n">w</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
		<span class="k">case</span> <span class="n">hex_direction</span><span class="o">::</span><span class="n">se</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>
		<span class="k">case</span> <span class="n">hex_direction</span><span class="o">::</span><span class="n">sw</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>
		<span class="k">case</span> <span class="n">hex_direction</span><span class="o">::</span><span class="n">ne</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
		<span class="k">case</span> <span class="n">hex_direction</span><span class="o">::</span><span class="n">nw</span><span class="p">:</span> <span class="k">return</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
	<span class="p">}</span>
	
	<span class="k">return</span><span class="p">{};</span>
<span class="p">}</span></code></pre>
</figure>

<p>As you can see, I chose axial coordinates. To understand why exactly that works, I would like to once again refer you to <a href="https://www.redblobgames.com/grids/hexagons/">this wonderful explanation</a>, which is far better than anything I could offer on that topic.</p>

<p>With that groundwork laid(and an overloaded operator» for parsing directions), the input based flipping is rather straightforward:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">point2d</span><span class="p">,</span><span class="n">color</span><span class="o">&gt;</span> <span class="n">colors</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span><span class="n">line</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">strm</span><span class="p">;</span>
	<span class="n">strm</span><span class="o">&lt;&lt;</span><span class="n">line</span><span class="p">;</span>
	
	<span class="n">point2d</span> <span class="n">pos</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">hex_direction</span> <span class="n">d</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">strm</span><span class="o">&gt;&gt;</span><span class="n">d</span><span class="p">)</span>
		<span class="n">pos</span><span class="o">+=</span><span class="n">to_vec2d</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
	
	<span class="n">colors</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">=</span><span class="n">flip</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">pos</span><span class="p">]);</span>
<span class="p">}</span></code></pre>
</figure>

<h3 id="part-2-23">Part 2</h3>

<p>And here we come to the reason for all those shenanigans. We had a seating area cellular automaton, we had a 4 dimensional cellular automaton, why not have one on a hex grid?</p>

<p>The code is almost identical to the one used for arbitrarily dimensional hypercubes before, so in case anything is unclear, I suggest looking at my solution for Day 17. If anything remains unclear, feel free to leave a comment on my blog or simply send me an email ;-)</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">update</span><span class="o">=</span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">point2d</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">counts</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">:</span> <span class="n">colors</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="n">color</span><span class="o">::</span><span class="n">white</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">n</span><span class="o">:</span> <span class="p">{</span><span class="n">hex_direction</span><span class="o">::</span><span class="n">e</span><span class="p">,</span><span class="n">hex_direction</span><span class="o">::</span><span class="n">w</span><span class="p">,</span><span class="n">hex_direction</span><span class="o">::</span><span class="n">ne</span><span class="p">,</span> <span class="n">hex_direction</span><span class="o">::</span><span class="n">nw</span><span class="p">,</span> <span class="n">hex_direction</span><span class="o">::</span><span class="n">sw</span><span class="p">,</span> <span class="n">hex_direction</span><span class="o">::</span><span class="n">se</span><span class="p">})</span>
			<span class="o">++</span><span class="n">counts</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">to_vec2d</span><span class="p">(</span><span class="n">n</span><span class="p">)];</span>
	<span class="p">}</span>
	
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">:</span> <span class="n">colors</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="n">color</span><span class="o">::</span><span class="n">black</span><span class="p">)</span>
			<span class="n">counts</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">=</span><span class="n">counts</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
	
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">cnt</span><span class="p">]</span><span class="o">:</span> <span class="n">counts</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">auto</span><span class="o">&amp;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="n">color</span><span class="o">::</span><span class="n">black</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cnt</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">cnt</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">))</span>
			<span class="n">c</span><span class="o">=</span><span class="n">color</span><span class="o">::</span><span class="n">white</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">==</span><span class="n">color</span><span class="o">::</span><span class="n">white</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
			<span class="n">c</span><span class="o">=</span><span class="n">color</span><span class="o">::</span><span class="n">black</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span></code></pre>
</figure>

<h2 id="day-25"><a href="https://github.com/philipplenk/adventofcode20/tree/main/25">Day 25</a></h2>

<p>For the final task this year, which - as is traditional - came in just one part, we had to break what was basically a <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman key exchange</a> with very small, brute forceable numbers.</p>

<p>I was so glad I had that multiplicative inverse function from day 13 lying around that I immediately used it to determine the loop number:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">powers_of_7</span><span class="p">;</span>
<span class="n">powers_of_7</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100000000</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">powers_of_7</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">powers_of_7</span><span class="p">),[</span><span class="n">curr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)]()</span> <span class="k">mutable</span> <span class="p">{</span> <span class="k">auto</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span> <span class="n">curr</span><span class="o">=</span><span class="n">curr</span><span class="o">*</span><span class="mi">7</span><span class="o">%</span><span class="n">modulus</span><span class="p">;</span> <span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span> <span class="p">});</span>

<span class="k">const</span> <span class="k">auto</span> <span class="n">which_power_of_7</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">powers_of_7</span><span class="p">),</span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">powers_of_7</span><span class="p">),</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">powers_of_7</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">auto</span> <span class="n">find_factor</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">auto</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">multiplicative_inverse</span><span class="p">(</span><span class="n">subject_number</span><span class="p">,</span><span class="n">modulus</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">inv</span><span class="o">*</span><span class="n">key</span><span class="p">)</span><span class="o">%</span><span class="n">modulus</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="n">which_power_of_7</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</figure>

<p>Using that result, I could simply execute the algorithm as described to obtain the unknown key:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">transform_with</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">subject_number</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">loop_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">loop_size</span><span class="o">--</span><span class="p">)</span>
		<span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="o">*</span><span class="n">subject_number</span><span class="o">%</span><span class="n">modulus</span><span class="p">;</span>
	
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>Turns out, however, that this is incredibly wasteful and instead of precomputing all those powers, I could simply do the same computations with the known key whilst counting the iterations:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">find_factor</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">value</span><span class="o">!=</span><span class="n">key</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">value</span><span class="o">*=</span><span class="n">subject_number</span><span class="p">;</span>
		<span class="n">value</span><span class="o">%=</span><span class="n">modulus</span><span class="p">;</span>
		<span class="o">++</span><span class="n">loop</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">loop</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<h1 id="conclusion">Conclusion</h1>

<h2 id="closing-thoughts-on-this-edition">Closing thoughts on this edition</h2>

<p>And that is it for this year. I tragically never made it onto the leaderboard, but that doesn’t matter.<sup id="fnref:pain" role="doc-noteref"><a href="#fn:pain" class="footnote" rel="footnote">11</a></sup> I had a tremendous amount of fun and learned a lot.</p>

<p>There were a bunch of problems that made me think for what seemed like eons, searching, despairing, believing that there must be some better solution available. Yet, just like real life 2020, things really were as bad as they seemed and all we could do was try and grind through. Save our energy, do it as efficient as possible, with as little lasting damage as possible, but still: the only way out was putting in the work. Every single step. Slowly and tediously crawling to the finishing line.</p>

<p>Sadly, 2020 also marked the day of <a href="https://en.wikipedia.org/wiki/John_Horton_Conway">John Conway’s</a> passing, his absence was felt and his legacy honored with variations of his <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a> featured rather prominently.</p>

<p>This edition was - in my humble opinion - not the most difficult edition ever and quite harmless compared to 2019. Whilst I was hoping for a bit more of a challenge, that property proved really useful for convincing beginners to try it and learn from it. It is a delicate balance to strike.</p>

<h2 id="what-now">What now?</h2>

<p>After the event, someone posted a famous picture on reddit, <a href="https://www.reddit.com/r/adventofcode/comments/kkfl3e/morning_after_the_end_of_aoc_2020/">captioned “Morning after the end of AOC 2020”</a>
which so adequately expressed my feeling on the eve of the end that I have no choice but to reproduce it here:</p>

<p><img src="/images/advent_sadness.jpg" alt="Emptyness" title="What now?" class="centered-image" width="40%" /></p>

<p>After all this time of the puzzles being an integral part of my daily routine, it simply… ended.</p>

<p>This gaping hole in my chest had to be filled, I was craving for something, just anything to make this insufferable feeling of emptiness go away.</p>

<p>There are, of course, previous editions and you can still try and solve all of them. Unfortunately, that was no longer an option:</p>

<p><img src="/images/advent_complete.jpg" alt="Bragging" title="What now?" class="centered-image" width="40%" /></p>

<p>Great, I know. For all those who really like the interpreter exercises - and I really loved 2019’s intcode - there is one of Eric Wastl’s older puzzles, the <a href="https://challenge.synacor.com/">Synacor Challenge</a>. Alas, that was the path I took last year.</p>

<p>Oh right, there is one more option. The final day was great, I like cryptography and there is <a href="https://cryptopals.com/">the cryptopals challenge.</a> Why did that come to mind? Ah yes, I remember, I did that three years ago.</p>

<p>Luckily for me, after lots of soul and google searching, I discovered <a href="https://www.codingame.com">codingame</a>. Not only do they have a number of high quality puzzles, they foster a vibrant community - with puzzle solving and competitions regularly being live streamed and featured on the main site - and their <a href="https://www.codingame.com/multiplayer/clashofcode">clash of code</a> format, quick 15 minute speed coding competitions, proved mildly addicting. I might be spending an unhealthy amount of time on there. Please send help.</p>

<p>So, if you feel like I did, maybe one of the things mentioned above could be for you. Feel free to <a href="https://www.codingame.com/profile/a41e5f2d496e10e016a00669702741317380214">invite me to a clash</a> sometime, I am always up for a challenge.</p>

<p>If you fall into really deep despair and desperately need to bridge that gap some other way, you might as well read a blog post about it that appeared way too late for anyone to care ;-)</p>

<p>In my next post, which I will publish much much sooner, I promise, I shall return to the topic of emulation. In the meantime, I am looking forward to being destroyed in the comments.</p>

<hr />
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:celebrate" role="doc-endnote">
      <p>both of which I don’t particularly enjoy celebrating anyway <a href="#fnref:celebrate" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:why" role="doc-endnote">
      <p>As written about <a href="/2020/05/16/why.html">in my very first article on this blog</a> <a href="#fnref:why" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:party" role="doc-endnote">
      <p>It has likely long since ended, but that’s ok. Who likes parties anyway? I am sure - even without me - it was <a href="https://www.youtube.com/watch?v=KLoYVjDTYsM"><em>fine</em></a> <a href="#fnref:party" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:easter" role="doc-endnote">
      <p>One day I will <a href="https://adventofcode.com/2016/day/1">have my revenge!</a> <a href="#fnref:easter" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:excuse" role="doc-endnote">
      <p>And I get a most convenient excuse ;-) <a href="#fnref:excuse" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:advent_credit" role="doc-endnote">
      <p>image taken with gratitude <a href="https://en.wikipedia.org/wiki/File:Diciembre.jpg">from here</a> <a href="#fnref:advent_credit" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:speed" role="doc-endnote">
      <p>one might argue, however, that this very care does give non-compiled languages a special benefit for speed solving, but that is just me being bitter xD <a href="#fnref:speed" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:failure" role="doc-endnote">
      <p>which ultimately proved unsuccessful. <a href="#fnref:failure" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:ring" role="doc-endnote">
      <p>Unfortunately, we did not get a ring in C++20 either. Can anyone tell me what happend to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0059r4.pdf">p0059?</a> <a href="#fnref:ring" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:mathy" role="doc-endnote">
      <p>which is a good thing! <a href="#fnref:mathy" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:pain" role="doc-endnote">
      <p>Of course it does, my soul is crushed. If I have such a thing. Whatever that even means… <a href="#fnref:pain" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

	</div>


<script>talkyardServerUrl='https://comments-for-codemetas-de.talkyard.net';</script>
<script async defer src="https://c1.ty-cdn.net/-/talkyard-comments.min.js"></script>

<div class="talkyard-comments" data-discussion-id="Advent of Code 2020" style="margin-top: 45px;">
<noscript>Please enable Javascript to view comments.</noscript>
<p style="margin-top: 25px; opacity: 0.9; font-size: 96%">Comments powered by<a href="https://www.talkyard.io">Talkyard</a>.</p>
</div>



<a class="u-url" href="/2021/04/19/Advent-of-Code-2020.html" hidden></a>
</article>

			</div>
		</main><footer class="site-footer h-card">
	<data class="u-url" href="/"></data>

	<div class="wrapper">

		<div class="footer-col-wrapper">
			<div class="footer-col footer-col-1"><ul class="social-contact-list"><li>
			<a class="social-link" href="mailto:hannah.lenk@codemetas.de"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#email"></use></svg> <span>E-Mail</span></a>
		</li><li>
			<a class="social-link" href="https://www.linkedin.com/in/hannah-lenk-b9941613b"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span>LinkedIn</span></a>
		</li><li>
			<a class="social-link" href="https://www.twitch.tv/hannahlenk"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitch"></use></svg> <span>Twitch</span></a>
		</li></ul>
</div>

			<div class="footer-col footer-col-2"><ul class="social-showcase-list"><li>
		<a class="social-link" href="https://github.com/hannahlenk"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span>Github</span></a>
	</li>
	<li>
		<a class="social-link" href="https://stackoverflow.com/users/1760583"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#stackoverflow"></use></svg> <span>stackoverflow</span></a>
	</li>
<li>
		<a class="social-link" href="https://youtube.com/channel/UCeeufsDAkY633Ap4zyNHZVA"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#youtube"></use></svg> <span>YouTube</span></a>
	</li></ul>
</div>

		</div>

	</div>

</footer>
</body>

</html>
